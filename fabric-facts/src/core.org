#+SETUPFILE: ../../common/setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingfabricfactscore][Namespace: thi.ng.fabric.facts.core]]
     - [[#protocols][Protocols]]
     - [[#basic-types][Basic types]]
         - [[#fact-vertex][Fact vertex]]
         - [[#index-vertex][Index vertex]]
         - [[#factgraph][FactGraph]]
     - [[#queries][Queries]]
         - [[#basic-pattern-query][Basic pattern query]]
         - [[#parametric-query][Parametric query]]
         - [[#query-join][Query join]]
         - [[#query-ops][Query ops]]
         - [[#query-helpers][Query helpers]]
     - [[#rulebased-inference][Rulebased inference]]
     - [[#signal--collect-functions][Signal & collect functions]]
     - [[#graph-logging][Graph logging]]
     - [[#generic-helpers][Generic helpers]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.fabric.facts.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol IFactGraph
    (fact-indices [_])
    (add-fact! [_ t])
    (remove-fact! [_ t])
    (register-query! [_ q])
    (unregister-query! [_ q])
    (query-for-pattern [_ pattern]))

  (defprotocol IFactQuery
    (raw-pattern [_])
    (result-vertex [_]))
#+END_SRC

** Basic types

*** Fact vertex

#+BEGIN_SRC clojure :noweb-ref fact-v
(def ^:private fact-vertex-spec
  {::f/score-collect-fn (constantly 0)
   ::f/score-signal-fn  f/score-signal-with-new-edges})
#+END_SRC

*** Index vertex

#+BEGIN_SRC clojure :noweb-ref index-v
(defn- index-vertex
  [g spo]
  (f/add-vertex!
   g {} {::f/collect-fn      (collect-index spo)
         ::f/score-signal-fn f/score-signal-with-new-edges}))
#+END_SRC

*** FactGraph

#+BEGIN_SRC clojure :noweb-ref graph
(defrecord FactGraph
    [g indices facts queries rules]
  f/IComputeGraph
  (add-vertex!
    [_ val vspec] (f/add-vertex! g val vspec))
  (remove-vertex!
    [_ v] (f/remove-vertex! g v))
  (vertex-for-id
    [_ id] (f/vertex-for-id g id))
  (vertices
    [_] (f/vertices g))
  (add-edge!
    [_ src dest sig opts] (f/add-edge! g src dest sig opts))
  f/IWatch
  (add-watch!
    [_ type id f] (f/add-watch! g type id f) _)
  (remove-watch!
    [_ type id] (f/remove-watch! g type id) _)
  IFactGraph
  (fact-indices
    [_] indices)
  (add-fact!
    [_ t]
    (or (@facts t)
        (let [{:keys [subj pred obj]} indices
              v (f/add-vertex! g t fact-vertex-spec)]
          (f/add-edge! g v subj signal-fact :add)
          (f/add-edge! g v pred signal-fact :add)
          (f/add-edge! g v obj  signal-fact :add)
          (swap! facts assoc t v)
          v)))
  (remove-fact!
    [_ t]
    (if-let [v (@facts t)]
      (let [{:keys [subj pred obj]} indices]
        (f/add-edge! g v subj signal-fact :remove)
        (f/add-edge! g v pred signal-fact :remove)
        (f/add-edge! g v obj  signal-fact :remove)
        (swap! facts dissoc t)
        (f/remove-vertex! g v)
        v)
      (warn "attempting to remove unknown fact:" t)))
  (register-query!
    [_ q] (swap! queries assoc (raw-pattern q) q) q)
  (unregister-query!
    [_ q] (swap! queries dissoc (raw-pattern q) nil))
  (query-for-pattern
    [_ pattern] (@queries pattern)))

#+END_SRC

**** Constructor

#+BEGIN_SRC clojure :noweb-ref graph
  (defn fact-graph
    [g]
    (map->FactGraph
     {:indices {:subj (index-vertex g 0)
                :pred (index-vertex g 1)
                :obj  (index-vertex g 2)}
      :facts (atom {})
      :queries (atom {})
      :rules   (atom {})
      :g       g}))
#+END_SRC

** Queries

#+BEGIN_SRC clojure :noweb-ref queries
#?(:clj (prefer-method print-method clojure.lang.IRecord clojure.lang.IDeref))

#+END_SRC

*** Basic pattern query

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord BasicFactQuery [id acc result pattern]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] pattern)
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [{:keys [subj pred obj]} (fact-indices g)
            acc  (f/add-vertex!
                  g {} {::f/collect-fn collect-select})
            res  (f/add-vertex!
                  g nil
                  {::f/collect-fn       (aggregate-select g)
                   ::f/score-collect-fn (score-collect-min-signal-vals 3)})
            [s p o] pattern
            this (assoc _ :acc acc :result res)]
        ;; TODO add index selection vertices, use existing if possible
        (f/add-edge! g subj acc signal-index-select [0 s])
        (f/add-edge! g pred acc signal-index-select [1 p])
        (f/add-edge! g obj  acc signal-index-select [2 o])
        (f/add-edge! g acc  res f/signal-forward nil)
        (register-query! g this)))
    (remove-from-graph!
      [_ g]
      (unregister-query! g _)
      (f/remove-vertex! g result)
      (f/remove-vertex! g acc)
      (assoc _ :acc nil :result nil)))

#+END_SRC

*** Parametric query

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord ParametricFactQuery
      [id sub-query result pattern]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] (mapv #(if-not (qvar? %) %) pattern))
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [[s p o]    pattern
            vs?        (qvar? s), vp? (qvar? p), vo? (qvar? o)
            vmap       (bind-translator vs? vp? vo? s p o)
            verify     (fact-verifier s p o vs? vp? vo?)
            res-tx     (comp (map #(if (verify %) (vmap %))) (filter identity))
            collect-fn (f/collect-pure
                        (fn [_ incoming]
                          (if-let [res (seq (peek incoming))]
                            (into #{} res-tx res)
                            #{})))
            q-pattern  (raw-pattern _)
            sub-q      (or (query-for-pattern g q-pattern) (add-query! g id q-pattern))
            res        (f/add-vertex! g nil {::f/collect-fn collect-fn})]
        (f/add-edge! g (result-vertex sub-q) res f/signal-forward nil)
        (assoc _ :sub-query sub-q :result res)))
    (remove-from-graph!
      [_ g]
      (f/remove-vertex! g result)
      (when (sole-user? (result-vertex sub-query) result)
        (f/remove-from-graph! sub-query g))
      (assoc _ :sub-query nil :result nil)))

#+END_SRC

*** Query join

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord FactQueryJoin [id lhs rhs result]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] nil)
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [^thi.ng.fabric.core.Vertex lhs-v  (result-vertex lhs)
            ^thi.ng.fabric.core.Vertex rhs-v  (result-vertex rhs)
            lhs-id (f/vertex-id lhs-v)
            rhs-id (f/vertex-id rhs-v)
            join   (f/add-vertex!
                    g nil
                    {::f/collect-fn
                     (fn [^thi.ng.fabric.core.Vertex vertex]
                       (let [sig-map (f/signal-map vertex)
                             a (sig-map lhs-id)
                             b (sig-map rhs-id)]
                         (debug (f/vertex-id vertex) :join-sets a b)
                         (reset! (.-value vertex) (set/join a b))))
                     ::f/score-collect-fn
                     score-collect-join})]
        (f/add-edge! g lhs-v join f/signal-forward nil)
        (f/add-edge! g rhs-v join f/signal-forward nil)
        (assoc _ :result join)))
    (remove-from-graph!
      [_ g]
      (f/remove-vertex! g result)
      (when (sole-user? (result-vertex lhs) result)
        (f/remove-from-graph! lhs g))
      (when (sole-user? (result-vertex rhs) result)
        (f/remove-from-graph! rhs g))))
#+END_SRC

*** Query ops

#+BEGIN_SRC clojure :noweb-ref query-ops
  (defn add-query!
    [g id pattern]
    (f/add-to-graph!
     (map->BasicFactQuery {:id id :pattern pattern}) g))

  (defn add-param-query!
    [g id pattern]
    (f/add-to-graph!
     (map->ParametricFactQuery {:id id :pattern pattern}) g))

  (defn add-join!
    ([g lhs rhs]
     (add-join! g (random-id) lhs rhs))
    ([g id lhs rhs]
     (f/add-to-graph!
      (map->FactQueryJoin {:id id :lhs lhs :rhs rhs}) g)))

  (defn add-query-join!
    [g a b & more]
    (reduce
     (fn [acc p]
       (add-join! g (random-id) acc (add-param-query! g (random-id) p)))
     (add-join!
      g (random-id)
      (add-param-query! g (random-id) a)
      (add-param-query! g (random-id) b))
     more))

  (defn add-query-filter!
    [g q flt]
    (let [tx (comp (mapcat identity) (filter flt))
          fv (f/add-vertex!
              g nil
              {::f/collect-fn
               (f/collect-pure
                (fn [_ incoming] (sequence tx incoming)))})]
      (f/add-edge! g (result-vertex q) fv f/signal-forward nil)
      fv))

  (defn add-counter!
    [g src]
    (let [v (f/add-vertex!
             g nil
             {::f/collect-fn (f/collect-pure (fn [_ in] (count (peek in))))})]
      (f/add-edge! g src v f/signal-forward nil)
      v))
#+END_SRC

*** Query helpers

#+BEGIN_SRC clojure :noweb-ref query-helpers
  (defn- qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (= \? (.charAt ^String (name x) 0))))

  (defn- bind-translator
    [vs? vp? vo? s p o]
    (if vs?
      (if vp?
        (if vo?
          (fn [r] {s (r 0) p (r 1) o (r 2)})
          (fn [r] {s (r 0) p (r 1)}))
        (if vo?
          (fn [r] {s (r 0) o (r 2)})
          (fn [r] {s (r 0)})))
      (if vp?
        (if vo?
          (fn [r] {p (r 1) o (r 2)})
          (fn [r] {p (r 1)}))
        (if vo?
          (fn [r] {o (r 2)})
          (fn [_] {})))))

  (defn- fact-verifier
    [ts tp to vars varp varo]
    (cond
      (and vars varp varo) (cond
                             (= ts tp to) (fn [r] (= (r 0) (r 1) (r 2)))
                             (= ts tp) (fn [r] (and (= (r 0) (r 1)) (not= (r 0) (r 2))))
                             (= ts to) (fn [r] (and (= (r 0) (r 2)) (not= (r 0) (r 1))))
                             (= tp to) (fn [r] (and (= (r 1) (r 2)) (not= (r 0) (r 1))))
                             :else (constantly true))
      (and vars varp)      (if (= ts tp)
                             (fn [r] (= (r 0) (r 1)))
                             (fn [r] (not= (r 0) (r 1))))
      (and vars varo)      (if (= ts to)
                             (fn [r] (= (r 0) (r 2)))
                             (fn [r] (not= (r 0) (r 2))))
      (and varp varo)      (if (= tp to)
                             (fn [r] (= (r 1) (r 2)))
                             (fn [r] (not= (r 1) (r 2))))
      :else                (constantly true)))
#+END_SRC

** Rulebased inference

#+BEGIN_SRC clojure :noweb-ref inference
  (defrecord FactInferenceRule
      [id query patterns production inf]
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [q   (apply add-query-join! g patterns)
            inf (f/add-vertex!
                 g #{} {::f/collect-fn (collect-inference g production)})]
        (f/add-edge! g (result-vertex q) inf f/signal-forward nil)
        (assoc _ :query q :inf inf))))

#+END_SRC

#+BEGIN_SRC clojure :noweb-ref inference
  (defn add-rule!
    [g id query production]
    (f/add-to-graph!
     (map->FactInferenceRule
      {:id id :patterns query :production production})
     g))
#+END_SRC

** Signal & collect functions

#+BEGIN_SRC clojure :noweb-ref sig-coll
  (defn- signal-fact
    [^thi.ng.fabric.core.Vertex vertex op] [op (f/vertex-id vertex) @vertex])

  (defn- collect-index
    [spo]
    (f/collect-pure
     (fn [val incoming]
       ;;(debug :update-index spo incoming)
       (debug :old-index val)
       (let [val (transduce
                  (map (fn [[op id t]] [op id (nth t spo)]))
                  (completing
                   (fn [acc [op id x]]
                     (case op
                       :add    (update acc x (fnil conj #{}) id)
                       :remove (if-let [idx (acc x)]
                                 (if (= #{id} idx)
                                   (dissoc acc x)
                                   (update acc x disj id))
                                 acc)
                       (do (warn "ignoring unknown index signal op:" op)
                           acc))))
                  val incoming)]
         (debug :new-index val)
         val))))

  (defn- signal-index-select
    [vertex [idx sel]]
    [idx (if sel (@vertex sel [nil]) (->> @vertex vals (mapcat identity) (set)))])

  (def ^:private collect-select
    (f/collect-pure
     (fn [val incoming]
       (let [val (reduce (fn [acc [idx res]] (assoc acc idx res)) val incoming)]
         ;;(debug :coll-select val incoming)
         val))))

  (defn- score-collect-min-signal-vals
    [num]
    (fn [^thi.ng.fabric.core.Vertex vertex]
      (if (> num (count (vals (peek (f/uncollected-signals vertex))))) 0 1)))

  (defn- score-collect-min-signals
    [num]
    (fn [^thi.ng.fabric.core.Vertex vertex]
      (if (> num (count (f/uncollected-signals vertex))) 0 1)))

  (defn- aggregate-select
    [g]
    (f/collect-pure
     (fn [_ incoming]
       (let [res (vals (peek incoming))]
         ;;(debug :agg-incoming res)
         (if (every? #(not= [nil] %) res)
           (->> res
                (into #{} (map #(disj % nil)))
                (sort-by count)
                (reduce set/intersection)
                (into #{}
                      (comp (map #(f/vertex-for-id g %))
                            (filter identity)
                            (map deref))))
           #{})))))

  (defn- score-collect-join
    [^thi.ng.fabric.core.Vertex vertex]
    (if (and (seq (f/uncollected-signals vertex))
             (== (count (f/signal-map vertex)) 2))
      1 0))

  (defn- collect-inference
    [g production]
    (fn [^thi.ng.fabric.core.Vertex vertex]
      (let [prev @vertex
            in   (reduce into #{} (f/uncollected-signals vertex))
            adds (set/difference in prev)
            inferred (mapcat production adds)]
        (debug (f/vertex-id vertex) :additions adds)
        (doseq [[op t :as inf] inferred]
          (case op
            :+ (do (debug :add-fact t)
                   (add-fact! g t))
            :- (do (debug :remove-fact t)
                   (remove-fact! g t))
            (warn "invalid inference:" inf)))
        (swap! (.-value vertex) set/union adds))))
#+END_SRC

** Graph logging

#+BEGIN_SRC clojure :noweb-ref logger
  (def fact-log-transducer
    (comp
     (filter (fn [[op v]] (and (#{:add-vertex :remove-vertex} op) (vector? @v))))
     (map (fn [[op v]] [({:add-vertex :+ :remove-vertex :-} op) @v]))))

  (defn add-fact-graph-logger
    [g log-fn]
    (let [ch        (chan 1024 fact-log-transducer)
          watch-id  (random-id)
          log->chan #(go (>! ch %))]
      (go-loop []
        (let [t (<! ch)]
          (when t
            (log-fn t)
            (recur))))
      (f/add-watch! g :add-vertex watch-id log->chan)
      (f/add-watch! g :remove-vertex watch-id log->chan)
      {:graph g :chan ch :watch-id watch-id}))

  (defn remove-fact-graph-logger
    [{:keys [graph watch-id chan]}]
    (f/remove-watch! graph :add-vertex watch-id)
    (f/remove-watch! graph :remove-vertex watch-id)
    (close! chan))
#+END_SRC

** Generic helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn- sole-user?
    [src user]
    (let [n (f/neighbors src)]
      (and (== 1 (count n)) (= user (first n)))))

  (defn- random-id
    [] (keyword (gensym)))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/fabric/facts/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.fabric.facts.core
    #?@(:clj
        [(:require
          [thi.ng.fabric.core :as f]
          [clojure.set :as set]
          [clojure.core.async :as a :refer [go go-loop chan close! <! >! alts! timeout]]
          [taoensso.timbre :refer [debug info warn]])]
        :cljs
        [(:require-macros
          [cljs.core.async.macros :refer [go go-loop]]
          [cljs-log.core :refer [debug info warn]])
         (:require
          [thi.ng.fabric.core :as f]
          [clojure.set :as set]
          [cljs.core.async :refer [chan close! <! >! alts! timeout]])]))

  (declare add-query! add-query-join!)

  <<protos>>

  <<helpers>>

  <<sig-coll>>

  <<query-helpers>>

  <<fact-v>>

  <<index-v>>

  <<graph>>

  <<queries>>

  <<query-ops>>

  <<inference>>

  <<logger>>
#+END_SRC
