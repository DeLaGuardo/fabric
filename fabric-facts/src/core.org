#+SETUPFILE: ../../common/setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingfabricfactscore][Namespace: thi.ng.fabric.facts.core]]
     - [[#protocols][Protocols]]
     - [[#basic-types][Basic types]]
         - [[#fact-vertex][Fact vertex]]
         - [[#factgraph][FactGraph]]
     - [[#queries][Queries]]
         - [[#overview--example][Overview & example]]
         - [[#override-print-methods][Override print methods]]
         - [[#index-selection][Index selection]]
         - [[#basic-pattern-query][Basic pattern query]]
         - [[#parametric-query][Parametric query]]
         - [[#query-join][Query join]]
         - [[#query-union][Query union]]
         - [[#query-constructors][Query constructors]]
         - [[#query-helpers][Query helpers]]
     - [[#todo-rulebased-inference][TODO Rulebased inference]]
     - [[#signal--collect-functions][Signal & collect functions]]
     - [[#graph-logging][Graph logging]]
     - [[#generic-helpers][Generic helpers]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.fabric.facts.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol IFactGraph
    (fact-indices [_])
    (add-fact! [_ t])
    (remove-fact! [_ t]))

  (defprotocol ICache
    (cached [_ type k])
    (cache! [_ type k v])
    (expire! [_ type k]))

  (defprotocol IFactQuery
    (raw-pattern [_])
    (result-vertex [_]))
#+END_SRC

** Basic types

*** Fact vertex

Facts are RDF-style triples (vectors) of =[subject predicate object]=,
stored in normal vertices. However, each fact vertex is configured to
never collect (facts are immutable) and signal only once when added
(or removed) from the graph.

Any Clojure value can be used as subject/pred/obj, though in most
cases you'll want to use strings, keywords, symbols, UUIDs or numbers.

Example facts:

#+BEGIN_SRC clojure
;; P-123 has name Alice
["P-123" :name "Alice"]

;; toxi is author of fabric
['toxi 'author 'fabric]

;; subject with UUID ... has a template function f
[#uuid "cffedb78-0e16-4f7e-8494-a19b749e771b" :template-fn (fn [title] [:div [:h1 title]])]
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref fact-v
  (def ^:private fact-vertex-spec
    {::f/score-collect-fn (constantly 0)
     ::f/score-signal-fn  f/score-signal-with-new-edges})
#+END_SRC

*** FactGraph

The default implementation of the =FactGraph= wraps an existing
=IComputeGraph= instance and provides an extended API via the
=IFactGraph= and =ICache= protocols.

**** Fact indexing

The =FactGraph= indexes all facts by their subject, predicate and
object (SPO) values. These indices are special vertices, automatically
added during graph construction and all fact vertices are
automatically connected to (and only to!) these indices. When queries
are added to the graph, they indirectly attach themselves to the 3
indices (via intermediate index selection vertices, see Queries
section below) and are notified each time their index selection is
changing.

**** Entity caching

The =ICache= protocol is used to cache various query related entities
for DRY reasons. Intermediate result caching is not just done for
performance reasons, but also to minimize memory usage, since queries
often make use of similar patterns and sub-patterns (e.g. two separate
query joins might use the same pattern as LHS or RHS). Currently the
cache is an atom with a nested map and these top-level keys:

- =::index-sel= - caches vertices selecting a specific key from any of
  the 3 SPO indices (or a wildcard selection). These vertices
  basically act as sub-sub-queries of a specific S, P or O.
- =::queries= - caches existing single-pattern queries based on their
  query pattern (no query joins or unions are cached). Note: the
  cached values are NOT vertices, but query entities (defrecords w/
  =IFactQuery= implementations)
- =::rules= - caches inference rules based on their ID (also
  defrecords)

**** Implementation

#+BEGIN_SRC clojure :noweb-ref graph
(defrecord FactGraph
    [g indices facts cache]
  f/IComputeGraph
  (add-vertex!
    [_ val vspec] (f/add-vertex! g val vspec))
  (remove-vertex!
    [_ v] (f/remove-vertex! g v))
  (vertex-for-id
    [_ id] (f/vertex-for-id g id))
  (vertices
    [_] (f/vertices g))
  (add-edge!
    [_ src dest sig opts] (f/add-edge! g src dest sig opts))
  f/IWatch
  (add-watch!
    [_ type id f] (f/add-watch! g type id f) _)
  (remove-watch!
    [_ type id] (f/remove-watch! g type id) _)
  IFactGraph
  (fact-indices
    [_] indices)
  (add-fact!
    [_ t]
    (or (@facts t)
        (let [{:keys [subj pred obj]} indices
              v (f/add-vertex! g t fact-vertex-spec)]
          (f/add-edge! g v subj signal-fact :add)
          (f/add-edge! g v pred signal-fact :add)
          (f/add-edge! g v obj  signal-fact :add)
          (swap! facts assoc t v)
          v)))
  (remove-fact!
    [_ t]
    (if-let [v (@facts t)]
      (let [{:keys [subj pred obj]} indices]
        (f/add-edge! g v subj signal-fact :remove)
        (f/add-edge! g v pred signal-fact :remove)
        (f/add-edge! g v obj  signal-fact :remove)
        (swap! facts dissoc t)
        (f/remove-vertex! g v)
        v)
      (warn "attempting to remove unknown fact:" t)))
  ICache
  (cached
    [_ type k] (get-in @cache [type k]))
  (cache!
    [_ type k v] (swap! cache assoc-in [type k] v) v)
  (expire!
    [_ type k] (swap! cache update type dissoc k) nil))
#+END_SRC

**** Constructor

#+BEGIN_SRC clojure :noweb-ref graph
  (defn fact-graph
    [g]
    (map->FactGraph
     {:indices {:subj (index-vertex g 0)
                :pred (index-vertex g 1)
                :obj  (index-vertex g 2)}
      :facts   (atom {})
      :cache   (atom {})
      :g       g}))
#+END_SRC

**** Index vertex

This is the helper function used by the =FactGraph= constructor to
create a single SPO index vertex.

#+BEGIN_SRC clojure :noweb-ref index-v
(defn- index-vertex
  [g spo]
  (f/add-vertex!
   g {} {::f/collect-fn      (collect-index spo)
         ::f/score-signal-fn f/score-signal-with-new-edges}))
#+END_SRC

** Queries

*** Overview & example

This diagram illustrates how queries are generally implemented via multiple
vertices in the graph. There're two queries here:

Q1: All "friend" facts
Q2: All facts about subject "alice"

- Row 1 : 4 facts stored in the graph
- Row 2 : S, P, O index vertices
- Row 3 : Index selection vertices (the blue vertex is re-used by both queries)
- Row 4 : Query accumulators (combine intersection of index selection sets)
- Row 5 : Query results (basic queries)
- Row 6 : Query results (parametric queries)

The vertex values of the result row differ based on the query type
used. In this example Q1 is a basic fact query and Q2 a parametric
query with variables. The result set of a basic query contains the
matching facts. The result set of parametric queries contains unique
maps of variable bindings.

[[../../assets/query-example01.png]]

Graphviz file to generate the above example:

#+BEGIN_SRC dot :tangle ../../assets/query-example01.dot
digraph g {
  node[color="black",style="filled",fontname="Inconsolata",fontcolor="white",fontsize=11];
  edge[fontname="Inconsolata",fontsize=9];

  f1[label="1 [alice friend bob]"];
  f2[label="2 [bob friend charlie]"];
  f3[label="3 [alice friend dora]"];
  f4[label="4 [alice email a@b.com]"];
  is[label="subj: {alice #{1 3 4} bob #{2}",color="#cc0066"];
  ip[label="pred: {friend #{1 2 3} email #{4}",color="#cc6600"];
  io[label="obj: {bob #{1} charlie #{2} dora #{3} a@b.com #{4}",color="#0066cc"];
  f1 -> is; f1 -> ip; f1 -> io;
  f2 -> is; f2 -> ip; f2 -> io;
  f3 -> is; f3 -> ip; f3 -> io;
  f4 -> is; f4 -> ip; f4 -> io;

  q1[label="Q1: [nil friend nil]"];
  q2[label="Q2: [alice ?p ?o]"];

  sq1[label="[0 #{1 2 3 4}]",color="#cc0066"];
  pq1[label="[1 #{1 2 3}]",color="#cc6600"];
  oq1[label="[2 #{1 2 3 4}]",color="#0066cc"];

  q1res[label="#{[alice friend bob] [bob friend charlie] [alice friend dora]}"];

  is -> sq1[label="[0 nil]"];
  sq1 -> q1 -> q1res;
  ip -> pq1[label="[1 friend]"];
  pq1 -> q1;
  io -> oq1[label="[2 nil]"];
  oq1 -> q1;

  sq2[label="[0 #{1 3 4}]",color="#cc0066"];
  pq2[label="[1 #{1 2 3 4}",color="#cc6600"];

  q2res[label="#{[alice friend bob] [alice friend dora] [alice email a@b.com]}"];
  q2final[label="#{{?p friend ?o bob} {?p friend ?o dora} {?p email ?o a@b.com}}"];

  is -> sq2[label="[0 alice]"];
  sq2 -> q2 -> q2res -> q2final;
  ip -> pq2[label="[1 nil]"];
  pq2 -> q2;
  oq1 -> q2;
}
#+END_SRC

In code form this same graph could be constructed like this:

#+BEGIN_SRC clojure :tangle ../babel/examples/query-example01.cljc
  (require '[thi.ng.fabric.core :as f])
  (require '[thi.ng.fabric.facts.core :as ff])

  (def g (ff/fact-graph (f/compute-graph)))
  (ff/add-fact! g '[alice friend bob])
  (ff/add-fact! g '[bob friend charlie])
  (ff/add-fact! g '[alice friend dora])
  (ff/add-fact! g '[alice email "a@b.com"])

  (def friends (ff/add-query! g '[nil friend nil]))
  (def alice   (ff/add-param-query! g '[alice ?p ?o]))

  (f/execute! (f/sync-execution-context {:graph g}))

  @friends
  ;; #{[alice friend dora] [bob friend charlie] [alice friend bob]}
  @alice
  ;; #{{?p email, ?o "a@b.com"} {?p friend, ?o bob} {?p friend, ?o dora}}
#+END_SRC

*** Override print methods

#+BEGIN_SRC clojure :noweb-ref queries
#?(:clj (prefer-method print-method clojure.lang.IRecord clojure.lang.IDeref))

#+END_SRC


*** Index selection

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord FactIndexSelection [index sel vertex]
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [v (f/add-vertex!
               g nil
               {::f/score-signal-fn f/score-signal-with-new-edges
                ::f/collect-fn      (f/collect-pure (fn [_ in] (peek in)))})]
        (f/add-edge! g index v signal-index-select sel)
        (cache! g ::index-sel sel (assoc _ :vertex v))))
    (remove-from-graph!
      [_ g] (f/remove-from-graph! _ g nil))
    (remove-from-graph!
      [_ g parent]
      (if (f/none-or-single-user? vertex parent)
        (do (warn :remove-index-sel sel)
            (f/disconnect-neighbor! index vertex)
            (f/remove-vertex! g vertex)
            true)
        (do (f/disconnect-neighbor! vertex parent)
            false))))
#+END_SRC

*** Basic pattern query

A =BasicFactQuery= is used to match a single or multiple facts without variable bindings:

- =['alice 'friend 'bob]= only matches the stated fact
- =[nil 'friend 'bob]= matches all facts which have predicate ='friend= and object ='bob=

In general, =nil= is used as wildcard to match any S, P or O position.
Therefore, the query pattern =[nil nil nil]= matches all facts in the
graph.

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord BasicFactQuery [acc selections result pattern]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] pattern)
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [{:keys [subj pred obj]} (fact-indices g)
            [s p o] pattern
            sel-s (index-selection g [0 s])
            sel-p (index-selection g [1 p])
            sel-o (index-selection g [2 o])
            acc   (f/add-vertex! g {} {::f/collect-fn collect-select})
            res   (f/add-vertex!
                   g nil
                   {::f/collect-fn       (aggregate-select g)
                    ::f/score-signal-fn  f/score-signal-with-new-edges
                    ::f/score-collect-fn (score-collect-min-signal-vals 3)})
            this  (assoc _ :acc acc :result res :selections [sel-s sel-p sel-o])]
        ;; TODO add index selection vertices, use existing if possible
        (f/add-edge! g (:vertex sel-s) acc f/signal-forward nil)
        (f/add-edge! g (:vertex sel-p) acc f/signal-forward nil)
        (f/add-edge! g (:vertex sel-o) acc f/signal-forward nil)
        (f/add-edge! g acc             res f/signal-forward nil)
        (cache! g ::queries pattern this)))
    (remove-from-graph!
      [_ g] (f/remove-from-graph! _ g nil))
    (remove-from-graph!
      [_ g parent]
      (if (f/none-or-single-user? result parent)
        (do (warn :remove-query pattern)
            (expire! g ::queries pattern)
            (f/remove-vertex! g result)
            (f/remove-vertex! g acc)
            (run! #(f/remove-from-graph! % g acc) selections)
            true)
        (do (f/disconnect-neighbor! result parent)
            false))))
#+END_SRC

*** Parametric query

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord ParametricFactQuery
      [sub-query result pattern]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] (mapv #(if-not (qvar? %) %) pattern))
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [[s p o]    pattern
            vs?        (qvar? s), vp? (qvar? p), vo? (qvar? o)
            vmap       (bind-translator vs? vp? vo? s p o)
            verify     (fact-verifier s p o vs? vp? vo?)
            res-tx     (comp (map #(if (verify %) (vmap %))) (filter identity))
            collect-fn (f/collect-pure
                        (fn [_ incoming]
                          (if-let [res (seq (peek incoming))]
                            (into #{} res-tx res)
                            #{})))
            sub-q      (add-query! g (raw-pattern _))
            res        (f/add-vertex!
                        g nil
                        {::f/collect-fn      collect-fn
                         ::f/score-signal-fn f/score-signal-with-new-edges})
            this       (assoc _ :sub-query sub-q :result res)]
        (f/add-edge! g (result-vertex sub-q) res f/signal-forward nil)
        (cache! g ::queries pattern this)))
    (remove-from-graph!
      [_ g] (f/remove-from-graph! _ g nil))
    (remove-from-graph!
      [_ g parent]
      (if (f/none-or-single-user? result parent)
        (do (warn :remove-param-query pattern)
            (expire! g ::queries pattern)
            (f/remove-vertex! g result)
            (f/remove-from-graph! sub-query g result)
            true)
        (do (f/disconnect-neighbor! result parent)
            false))))
#+END_SRC

*** Query join

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord FactQueryJoin [lhs rhs result join-fn]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] nil)
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [lhs-v  (result-vertex lhs)
            rhs-v  (result-vertex rhs)
            lhs-id (f/vertex-id lhs-v)
            rhs-id (f/vertex-id rhs-v)
            result (f/add-vertex!
                    g nil
                    {::f/collect-fn
                     (fn [vertex]
                       (let [sig-map (f/signal-map vertex)
                             a (sig-map lhs-id)
                             b (sig-map rhs-id)]
                         (debug (f/vertex-id vertex) :join-sets a b)
                         (f/set-value! vertex (join-fn a b))))
                     ::f/score-collect-fn score-collect-join
                     ::f/score-signal-fn  f/score-signal-with-new-edges})]
        (f/add-edge! g lhs-v result f/signal-forward nil)
        (f/add-edge! g rhs-v result f/signal-forward nil)
        (assoc _ :result result)))
    (remove-from-graph!
      [_ g] (f/remove-from-graph! _ g nil))
    (remove-from-graph!
      [_ g parent]
      (if (f/none-or-single-user? result parent)
        (do (warn :remove-query-join)
            (f/remove-vertex! g result)
            (f/remove-from-graph! lhs g result)
            (f/remove-from-graph! rhs g result)
            true)
        (do (f/disconnect-neighbor! result parent)
            false))))
#+END_SRC

*** Query union

#+BEGIN_SRC clojure :noweb-ref queries
  (defrecord FactQueryUnion [sub-queries result]
    #?@(:clj
         [clojure.lang.IDeref (deref [_] (when result @result))]
         :cljs
         [IDeref (-deref [_] (when result @result))])
    IFactQuery
    (raw-pattern
      [_] nil)
    (result-vertex
      [_] result)
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [res (f/add-vertex!
                 g nil
                 {::f/collect-fn
                  (fn [vertex]
                    (let [subs (vals (f/signal-map vertex))]
                      (f/set-value! vertex (reduce (fn [acc res] (if (seq res) (into acc res) acc)) subs))))
                  ::f/score-signal-fn f/score-signal-with-new-edges})]
        (run! #(f/add-edge! g (result-vertex %) res f/signal-forward nil) sub-queries)
        (assoc _ :result res)))
    (remove-from-graph!
      [_ g] (f/remove-from-graph! _ g nil))
    (remove-from-graph!
      [_ g parent]
      (if (f/none-or-single-user? result parent)
        (do (warn :remove-query-union)
            (f/remove-vertex! g result)
            (run! #(f/remove-from-graph! % g result) sub-queries)
            true)
        (do (f/disconnect-neighbor! result parent)
            false))))
#+END_SRC

*** Query constructors

#+BEGIN_SRC clojure :noweb-ref query-ops
  (defn index-selection
    [g sel]
    (if-let [sel (cached g ::index-sel sel)]
      (do (debug :reuse-index-sel (:sel sel)) sel)
      (f/add-to-graph!
       (map->FactIndexSelection
        {:index ((fact-indices g) ([:subj :pred :obj] (first sel)))
         :sel   sel}) g)))

  (defn add-query!
    [g pattern]
    (if-let [q (cached g ::queries pattern)]
      (do (debug :reuse-basic-query pattern) q)
      (f/add-to-graph!
       (map->BasicFactQuery {:pattern pattern}) g)))

  (defn add-param-query!
    [g pattern]
    (if-let [q (cached g ::queries pattern)]
      (do (debug :reuse-param-query pattern) q)
      (f/add-to-graph!
       (map->ParametricFactQuery {:pattern pattern}) g)))

  (defn add-join!
    ([g lhs rhs]
     (add-join! g join lhs rhs))
    ([g join-fn lhs rhs]
     (f/add-to-graph!
      (map->FactQueryJoin {:lhs lhs :rhs rhs :join-fn join-fn}) g)))

  (defn add-query-join!
    [g & patterns]
    {:pre [(<= 2 (count patterns))]}
    (let [[a b & more :as p] (sort-patterns patterns)]
      (debug :sorted-join-patterns p)
      (reduce
       (fn [acc p] (add-join! g join acc (add-param-query! g p)))
       (add-join! g join (add-param-query! g a) (add-param-query! g b))
       more)))

  (defn add-query-join-optional!
    [g a b & more]
    (reduce
     (fn [acc p] (add-join! g join-optional acc (add-param-query! g p)))
     (add-join! g join-optional (add-param-query! g a) (add-param-query! g b))
     more))

  (defn add-query-union!
    [g a b & queries]
    (f/add-to-graph!
     (map->FactQueryUnion {:sub-queries (into [a b] queries)}) g))

  (defn add-query-filter!
    [g flt q]
    (let [res (f/add-vertex!
               g nil
               {::f/collect-fn      (f/collect-pure (fn [_ in] (filter flt (peek in))))
                ::f/score-signal-fn f/score-signal-with-new-edges})]
      (f/add-edge! g (result-vertex q) res f/signal-forward nil)
      res))

  (defn add-query-group-by!
    [g gfn q]
    (let [res (f/add-vertex!
               g nil
               {::f/collect-fn      (f/collect-pure (fn [_ in] (group-by gfn (peek in))))
                ::f/score-signal-fn f/score-signal-with-new-edges})]
      (f/add-edge! g (result-vertex q) res f/signal-forward nil)
      res))

  (defn add-counter!
    [g src]
    (let [v (f/add-vertex!
             g nil
             {::f/collect-fn      (f/collect-pure (fn [_ in] (count (peek in))))
              ::f/score-signal-fn f/score-signal-with-new-edges})]
      (f/add-edge! g src v f/signal-forward nil)
      v))
#+END_SRC

*** Query helpers

#+BEGIN_SRC clojure :noweb-ref query-helpers
  (defn- qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (= \? (.charAt ^String (name x) 0))))

  (defn pattern-var-count
    [pattern]
    (count (filter qvar? pattern)))

  (defn sort-patterns
    [patterns]
    (sort-by pattern-var-count patterns))

  (defn- bind-translator
    [vs? vp? vo? s p o]
    (if vs?
      (if vp?
        (if vo?
          (fn [r] {s (r 0) p (r 1) o (r 2)})
          (fn [r] {s (r 0) p (r 1)}))
        (if vo?
          (fn [r] {s (r 0) o (r 2)})
          (fn [r] {s (r 0)})))
      (if vp?
        (if vo?
          (fn [r] {p (r 1) o (r 2)})
          (fn [r] {p (r 1)}))
        (if vo?
          (fn [r] {o (r 2)})
          (fn [_] {})))))

  (defn- fact-verifier
    [ts tp to vars varp varo]
    (cond
      (and vars varp varo) (cond
                             (= ts tp to) (fn [r] (= (r 0) (r 1) (r 2)))
                             (= ts tp) (fn [r] (and (= (r 0) (r 1)) (not= (r 0) (r 2))))
                             (= ts to) (fn [r] (and (= (r 0) (r 2)) (not= (r 0) (r 1))))
                             (= tp to) (fn [r] (and (= (r 1) (r 2)) (not= (r 0) (r 1))))
                             :else (constantly true))
      (and vars varp)      (if (= ts tp)
                             (fn [r] (= (r 0) (r 1)))
                             (fn [r] (not= (r 0) (r 1))))
      (and vars varo)      (if (= ts to)
                             (fn [r] (= (r 0) (r 2)))
                             (fn [r] (not= (r 0) (r 2))))
      (and varp varo)      (if (= tp to)
                             (fn [r] (= (r 1) (r 2)))
                             (fn [r] (not= (r 1) (r 2))))
      :else                (constantly true)))

  (defn select-keys*
    "Like like c.c/select-keys, but doesn't retain map's meta"
    {:static true}
    [map keyseq]
    (loop [ret {} keys (seq keyseq)]
      (if keys
        #?(:clj
           (let [entry (. clojure.lang.RT (find map (first keys)))]
             (recur
              (if entry (conj ret entry) ret)
              (next keys)))
           :cljs
           (let [key   (first keys)
                 entry (get map key ::not-found)]
             (recur
              (if (= entry ::not-found) ret (assoc ret key entry))
              (next keys))))
        ret)))

  (defn join
    "Optimized version of clojure.set/join (w/o key mapping & using transients)"
    [xrel yrel]
    (if (and (seq xrel) (seq yrel))
      (let [ks (set/intersection (set (keys (first xrel))) (set (keys (first yrel))))
            [r s] (if (<= (count xrel) (count yrel))
                    [xrel yrel]
                    [yrel xrel])
            idx (set/index r ks)]
        (persistent!
         (reduce
          (fn [ret x]
            (let [found (idx (select-keys* x ks))]
              (if found
                (reduce #(conj! %1 (conj %2 x)) ret found)
                ret)))
          (transient #{}) s)))
      #{}))

  (defn join-optional
    [a b]
    (loop [old (transient #{}), new (transient #{}), kb b]
      (if kb
        (let [kb' [(first kb)]
              [old new] (loop [old old, new new, ka a]
                          (if ka
                            (let [ka' (first ka)
                                  j (first (join [ka'] kb'))]
                              (if j
                                (recur (conj! old ka') (conj! new j) (next ka))
                                (recur old new (next ka))))
                            [old new]))]
          (recur old new (next kb)))
        (let [new (persistent! new)]
          (if (seq new)
            (into (apply disj (set a) (persistent! old)) new)
            a)))))
#+END_SRC

** TODO Rulebased inference

#+BEGIN_SRC clojure :noweb-ref inference
  (defrecord FactInferenceRule
      [id query patterns production inf]
    f/IGraphComponent
    (add-to-graph!
      [_ g]
      (let [q   (apply add-query-join! g patterns)
            inf (f/add-vertex!
                 g #{} {::f/collect-fn (collect-inference g production)})]
        (f/add-edge! g (result-vertex q) inf f/signal-forward nil)
        (cache! g ::rules id (assoc _ :query q :inf inf))))
    (remove-from-graph!
      [_ g] (f/remove-from-graph! _ g nil))
    (remove-from-graph!
      [_ g parent]
      (if (f/none-or-single-user? inf parent)
        (do (warn :remove-rule id)
            (f/remove-vertex! g inf)
            (f/remove-from-graph! query g inf)
            true)
        (do (f/disconnect-neighbor! inf parent)
            false))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref inference
  (defn add-rule!
    [g id query production]
    (f/add-to-graph!
     (map->FactInferenceRule
      {:id id :patterns query :production production})
     g))
#+END_SRC

** Signal & collect functions

#+BEGIN_SRC clojure :noweb-ref sig-coll
  (defn- signal-fact
    [vertex op] [op (f/vertex-id vertex) @vertex])

  (defn- collect-index
    [spo]
    (f/collect-pure
     (fn [val incoming]
       ;;(debug :update-index spo incoming)
       (debug :old-index val)
       (let [val (transduce
                  (map (fn [[op id t]] [op id (nth t spo)]))
                  (completing
                   (fn [acc [op id x]]
                     (case op
                       :add    (update acc x (fnil conj #{}) id)
                       :remove (if-let [idx (acc x)]
                                 (if (= #{id} idx)
                                   (dissoc acc x)
                                   (update acc x disj id))
                                 acc)
                       (do (warn "ignoring unknown index signal op:" op)
                           acc))))
                  val incoming)]
         (debug :new-index val)
         val))))

  (defn- signal-index-select
    [vertex [idx sel]]
    [idx (if sel (@vertex sel [nil]) (->> @vertex vals (mapcat identity) (set)))])

  (def ^:private collect-select
    (f/collect-pure
     (fn [val incoming]
       (let [val (reduce (fn [acc [idx res]] (assoc acc idx res)) val incoming)]
         ;;(debug :coll-select val incoming)
         val))))

  (defn- score-collect-min-signal-vals
    [num]
    (fn [vertex]
      (if (> num (count (vals (peek (f/uncollected-signals vertex))))) 0 1)))

  (defn- score-collect-min-signals
    [num]
    (fn [vertex]
      (if (> num (count (f/uncollected-signals vertex))) 0 1)))

  (defn- aggregate-select
    [g]
    (f/collect-pure
     (fn [_ incoming]
       (let [res (vals (peek incoming))]
         ;;(debug :agg-incoming res)
         (if (every? #(not= [nil] %) res)
           (->> res
                (into #{} (map #(disj % nil)))
                (sort-by count)
                (reduce set/intersection)
                (into #{}
                      (comp (map #(f/vertex-for-id g %))
                            (filter identity)
                            (map deref))))
           #{})))))

  (defn- score-collect-join
    [^thi.ng.fabric.core.Vertex vertex]
    (if (and (seq (f/uncollected-signals vertex))
             (== (count (f/signal-map vertex)) 2))
      1 0))

  (defn- collect-inference
    [g production]
    (fn [^thi.ng.fabric.core.Vertex vertex]
      (let [prev @vertex
            in   (reduce into #{} (f/uncollected-signals vertex))
            adds (set/difference in prev)
            inferred (mapcat production adds)]
        (debug (f/vertex-id vertex) :additions adds)
        (doseq [[op t :as inf] inferred]
          (case op
            :+ (do (debug :add-fact t)
                   (add-fact! g t))
            :- (do (debug :remove-fact t)
                   (remove-fact! g t))
            (warn "invalid inference:" inf)))
        (swap! (.-value vertex) set/union adds))))
#+END_SRC

** Graph logging

#+BEGIN_SRC clojure :noweb-ref logger
  (def fact-log-transducer
    (comp
     (filter (fn [[op v]] (and (#{:add-vertex :remove-vertex} op) (vector? @v))))
     (map (fn [[op v]] [({:add-vertex :+ :remove-vertex :-} op) @v]))))

  (defn add-fact-graph-logger
    [g log-fn]
    (let [ch        (chan 1024 fact-log-transducer)
          watch-id  (f/random-id)
          log->chan #(go (>! ch %))]
      (go-loop []
        (let [t (<! ch)]
          (when t
            (log-fn t)
            (recur))))
      (f/add-watch! g :add-vertex watch-id log->chan)
      (f/add-watch! g :remove-vertex watch-id log->chan)
      {:graph g :chan ch :watch-id watch-id}))

  (defn remove-fact-graph-logger
    [{:keys [graph watch-id chan]}]
    (f/remove-watch! graph :add-vertex watch-id)
    (f/remove-watch! graph :remove-vertex watch-id)
    (close! chan))
#+END_SRC

** Generic helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/fabric/facts/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.fabric.facts.core
    #?@(:clj
        [(:require
          [thi.ng.fabric.core :as f]
          [clojure.set :as set]
          [clojure.core.async :as a :refer [go go-loop chan close! <! >! alts! timeout]]
          [taoensso.timbre :refer [debug info warn]])]
        :cljs
        [(:require-macros
          [cljs.core.async.macros :refer [go go-loop]]
          [cljs-log.core :refer [debug info warn]])
         (:require
          [thi.ng.fabric.core :as f]
          [clojure.set :as set]
          [cljs.core.async :refer [chan close! <! >! alts! timeout]])]))

  (declare index-selection add-query! add-query-join!)

  <<protos>>

  <<helpers>>

  <<sig-coll>>

  <<query-helpers>>

  <<fact-v>>

  <<index-v>>

  <<graph>>

  <<queries>>

  <<query-ops>>

  <<inference>>

  <<logger>>
#+END_SRC
