#+SETUPFILE: ../../common/setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingfabricfactscore][Namespace: thi.ng.fabric.facts.core]]
     - [[#protocols][Protocols]]
     - [[#core-types--concepts][Core types & concepts]]
         - [[#facts][Facts]]
         - [[#factgraph][FactGraph]]
         - [[#fact-indexing][Fact indexing]]
         - [[#fact-transformation][Fact transformation]]
         - [[#entity-caching][Entity caching]]
         - [[#implementation][Implementation]]
         - [[#constructor][Constructor]]
         - [[#index-vertex][Index vertex]]
     - [[#queries][Queries]]
         - [[#overview--example][Overview & example]]
         - [[#index-selection][Index selection]]
         - [[#basic-pattern-query][Basic pattern query]]
         - [[#parametric-query][Parametric query]]
         - [[#query-join][Query join]]
         - [[#query-union][Query union]]
         - [[#path-queries][Path queries]]
         - [[#todo-query-result-modifiers][TODO Query result modifiers]]
         - [[#query-helpers][Query helpers]]
     - [[#rulebased-inference][Rulebased inference]]
     - [[#signal--collect-functions][Signal & collect functions]]
     - [[#graph-logging][Graph logging]]
     - [[#generic-helpers][Generic helpers]]
     - [[#complete-namespace-definition][Complete namespace definition]]
     - [[#todo-questions][TODO Questions]]
         - [[#maps-as-facts][maps as facts?]]

* Namespace: thi.ng.fabric.facts.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol IFactGraph
    (fact-indices [_])
    (fact-transform [_])
    (add-fact! [_ t])
    (remove-fact! [_ t]))

  (defprotocol ICache
    (cached [_ type k])
    (cache! [_ type k v])
    (expire! [_ type k]))

  (defprotocol IFactQuery
    (raw-pattern [_])
    (query-spec [_]))

  (defprotocol IQueryResult
    (result-vertex [_]))

  (defprotocol ITwoWayTransform
    (transform [_ x])
    (untransform [_ x]))
#+END_SRC

** Core types & concepts

*** Facts

Facts are simply vectors of (currently 3 or 4) items, e.g. =[subject
predicate object]= (for triples) and stored in normal vertices.
However, each fact vertex is configured to never collect (facts are
immutable) and signal only once when added (or removed) from the
graph.

Any Clojure value can be used as fact item, though in most
cases you'll want to use strings, keywords, symbols, UUIDs or numbers.

Example facts:

#+BEGIN_SRC clojure
;; P123 has name Alice
[:P123 :name "Alice"]

;; toxi is author of fabric
'[toxi author fabric]

;; in transaction UUID we state "XYZ" has a a template function f
[#uuid "cffedb78-0e16-4f7e-8494-a19b749e771b" "XYZ" :template-fn (fn [title] [:div [:h1 title]])]
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref fact-v
  (def ^:private fact-vertex-spec
    {::f/score-collect-fn (constantly 0)
     ::f/score-signal-fn  f/score-signal-with-new-edges})
#+END_SRC

*** FactGraph

Facts are stored in a =FactGraph= instance which has been configured
with a maximum fact length (currently 3 or 4 items per fact). The
default implementation of the =FactGraph= wraps an existing
=IComputeGraph= instance and provides an extended API via the
=IFactGraph= and =ICache= protocols.

*** Fact indexing

The =FactGraph= indexes all facts by their individual items (e.g.
subject, predicate and object values). These indices are special
vertices, automatically added during graph construction and all fact
vertices are automatically connected to (and only to!) these indices.
When queries are added to the graph, they indirectly attach themselves
to these indices (via intermediate index selection vertices, see
Queries section below) and are notified each time their index
selection is changing.

*** Fact transformation

The =ITwoWayTransform= protocol allows the graph to invisibly store
transformed facts, possibly in more compact form than specified by the
user. When a fact is added, the =transform= method of the transform
is applied. Queries automatically call =untransform= on their results,
so the user will be oblivious to the changed internal representation.

*Custom implementations MUST follow this rule:*

- Query variables (e.g. =?a=, Clojure symbols prefixed with =?=) and
  =nil= values MUST NOT be transformed.

**** Identity transform

This is a null transform (NOP), used when no fact transform is given
for a graph.

#+BEGIN_SRC clojure :noweb-ref fact-tx
  (def identity-transform
    (reify ITwoWayTransform
      (transform [_ x] x)
      (untransform [_ x] x)))
#+END_SRC

**** PName URI replacements

This transform is useful when dealing with Linked Data (RDF), where
most items are URIs. It's common practice in the LD community to
specify prefixes for various often used vocabularies. E.g. We might
define a prefix map and transform like this:

#+BEGIN_SRC clojure
  (def prefixes
   {"rdf"  "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   "rdfs" "http://www.w3.org/2000/01/rdf-schema#"
   "owl"  "http://www.w3.org/2002/07/owl#"})

  (def tx (prefix-transform prefixes))

  (transform tx "http://www.w3.org/2002/07/owl#Ontology")
  ;; ["owl" "Ontology"]

  (untransform tx ["owl" "Ontology"])
  ;; "http://www.w3.org/2002/07/owl#Ontology"
#+END_SRC

The transform phase takes such a prefix map and value. If value is a
string, attempts to find prefix from map and if found returns a 2-elem
vector of =[prefix name]=, else original.

The untransformer too takes the same prefix map and a value. If the
value is a vector as produced by the transformation fn and has a known
prefix, returns expanded string or else original value.

*Important note:* This transform only applies to single fact
 sub-items, to apply it to full facts, wrap it with others in
 =combine-transforms= (described below).

#+BEGIN_SRC clojure :noweb-ref fact-tx
  (defn prefix-transform
    [prefixes]
    (reify ITwoWayTransform
      (transform
        [_ x]
        (if (string? x)
          (loop [[[pre pn] & more] (seq prefixes)]
            (if pre
              (if (zero? (.indexOf ^String x ^String pn))
                [pre (subs x (count pn))]
                (recur more))
              x))
          x))
      (untransform
        [_ x]
        (if (vector? x)
          (if-let [p (prefixes (first x))]
            (str p (nth x 1))
            x)
          x))))
#+END_SRC

**** Global fact item indexing

This transform too applies to fact sub-items only (see note in
previous section) and maps values to/from unique index IDs.

In Clojure, the reverse index uses Zach Tellman's
[[https://github.com/clojure/data.int-map][org.clojure/data.int-map]] for faster and more memory efficient
behavior.

#+BEGIN_SRC clojure :noweb-ref fact-tx
  (defn global-index-transform
    []
    (let [index (atom #?(:clj  {:fwd {} :rev (imap/int-map) :id 0}
                         :cljs {:fwd {} :rev {} :id 0}))]
      (reify ITwoWayTransform
        (transform
          [_ x]
          (if (or (nil? x) (qvar? x))
            x
            (or ((@index :fwd) x)
                (let [curr (volatile! nil)]
                  (swap! index
                         #(let [id (:id %)]
                            (vreset! curr id)
                            (-> %
                                (update :id inc)
                                (update :fwd assoc x id)
                                (update :rev assoc id x))))
                  @curr))))
        (untransform
          [_ id] ((@index :rev) id id)))))
#+END_SRC

**** Higher-order transforms & composition

Transforms can be composed using the functions below:

- =compose-transforms= applies the given transforms serially (via
  =reduce=) and in reverse order for =untransform=.

- =one-way-transform= takes an =ITwoWayTransform= and modifies it to
  use =identity= as its reverse transformation, therefore keeping
  transformed values.

- =combine-transforms= applies 3 or 4 transforms in parallel (one per
  fact component) to (un)transform a single fact

#+BEGIN_SRC clojure :noweb-ref fact-tx
  (defn compose-transforms
    [& transforms]
    (let [rtx (reverse transforms)]
      (reify ITwoWayTransform
        (transform [_ x]
          (reduce #(transform %2 %) x transforms))
        (untransform [_ x]
          (reduce #(untransform %2 %) x rtx)))))

  (defn one-way-transform
    [tx]
    (reify ITwoWayTransform
      (transform [_ x] (transform tx x))
      (untransform [_ x] x)))

  (defn combine-transforms
    ([tx len]
     (apply combine-transforms (repeat len tx)))
    ([txs txp txo]
     (reify ITwoWayTransform
       (transform [_ fact]
         [(transform txs (first fact))
          (transform txp (nth fact 1))
          (transform txo (nth fact 2))])
       (untransform [_ fact]
         [(untransform txs (first fact))
          (untransform txp (nth fact 1))
          (untransform txo (nth fact 2))])))
    ([txt txs txp txo]
     (reify ITwoWayTransform
       (transform [_ fact]
         [(transform txt (first fact))
          (transform txs (nth fact 1))
          (transform txp (nth fact 2))
          (transform txo (nth fact 3))])
       (untransform [_ fact]
         [(untransform txt (first fact))
          (untransform txs (nth fact 1))
          (untransform txp (nth fact 2))
          (untransform txo (nth fact 3))]))))
#+END_SRC

*** Entity caching

The =ICache= protocol is used to cache various query related entities
for DRY reasons. Intermediate result caching is not just done for
performance reasons, but also to minimize memory usage, since queries
often make use of similar patterns and sub-patterns (e.g. two separate
query joins might use the same pattern as LHS or RHS). Currently the
cache is an atom with a nested map and these top-level keys:

- =::index-sel= - caches vertices selecting a specific key from any of
  the indices (or a wildcard selection). These vertices basically act
  as sub-sub-queries of a specific fact component.
- =::queries= - caches existing single-pattern queries based on their
  query pattern (no query joins or unions are cached). Note: the
  cached values are NOT vertices, but query entities (defrecords w/
  =IFactQuery= implementations)
- =::rules= - caches inference rules based on their ID (also
  defrecords)

*** Implementation

#+BEGIN_SRC clojure :noweb-ref graph
  (defrecord FactGraph
      [g indices facts cache ftx]
    f/IComputeGraph
    (add-vertex!
      [_ val vspec] (f/add-vertex! g val vspec))
    (remove-vertex!
      [_ v] (f/remove-vertex! g v))
    (vertex-for-id
      [_ id] (f/vertex-for-id g id))
    (vertices
      [_] (f/vertices g))
    (add-edge!
      [_ src dest sig opts] (f/add-edge! g src dest sig opts))
    f/IWatch
    (add-watch!
      [_ type id f] (f/add-watch! g type id f) _)
    (remove-watch!
      [_ type id] (f/remove-watch! g type id) _)
    IFactGraph
    (fact-indices
      [_] indices)
    (fact-transform
      [_] ftx)
    (add-fact!
      [_ f]
      (let [f' (transform ftx f)]
        (or (@facts f')
            (let [v (f/add-vertex! g f' fact-vertex-spec)]
              (debug :add-fact f f')
              (run! #(f/add-edge! g v % signal-fact :add) indices)
              (swap! facts assoc f' v)
              v))))
    (remove-fact!
      [_ f]
      (let [f' (transform ftx f)]
        (if-let [v (@facts f')]
          (do
            (debug :remove-fact f f')
            (run! #(f/add-edge! g v % signal-fact :remove) indices)
            (swap! facts dissoc f')
            (f/remove-vertex! g v)
            v)
          (warn "attempting to remove unknown fact:" f))))
    ICache
    (cached
      [_ type k] (get-in @cache [type k]))
    (cache!
      [_ type k v] (swap! cache assoc-in [type k] v) v)
    (expire!
      [_ type k] (swap! cache update type dissoc k) nil))
#+END_SRC

*** Constructor

#+BEGIN_SRC clojure :noweb-ref graph
  (defn fact-graph
    "Creates a new FactGraph instance configured with given options map:
    :graph     - backing IComputeGraph (default fabric.core/compute-graph)
    :len       - fact length (default 3)
    :index     - index vertex ctor (default index-vertex)
    :transform - fact transform (default none)"
    ([]
     (fact-graph {}))
    ([{:keys [graph len index transform]
       :or   {graph     (f/compute-graph)
              len       3
              index     index-vertex
              transform identity-transform}}]
     (map->FactGraph
      {:indices (mapv #(index graph %) (range len))
       :facts   (atom {})
       :cache   (atom {})
       :ftx     transform
       :g       graph})))
#+END_SRC

*** Index vertex

This is the helper function used by the =FactGraph= constructor to
create a single fact component index vertex.

#+BEGIN_SRC clojure :noweb-ref index-v
(defn- index-vertex
  [g idx]
  (f/add-vertex!
   g {} {::f/collect-fn      (collect-index idx)
         ::f/score-signal-fn f/score-signal-with-new-edges}))
#+END_SRC

** Queries
*** Overview & example

This diagram illustrates how queries are generally implemented via
multiple vertices in the graph, though we here use a graph with
triples only (SPO facts). There're two queries here:

Q1: All "friend" facts
Q2: All facts about subject "alice"

- Row 1 : 4 facts stored in the graph
- Row 2 : S, P, O index vertices
- Row 3 : Index selection vertices (the blue vertex is re-used by both queries)
- Row 4 : Query accumulators (combine intersection of index selection sets)
- Row 5 : Query results (basic queries)
- Row 6 : Query results (parametric queries)

The vertex values of the result row differ based on the query type
used. In this example Q1 is a basic fact query and Q2 a parametric
query with variables. The result set of a basic query contains the
matching facts. The result set of parametric queries contains unique
maps of variable bindings.

[[../../assets/query-example01.png]]

Graphviz file to generate the above example:

#+BEGIN_SRC dot :tangle ../../assets/query-example01.dot
digraph g {
  node[color="black",style="filled",fontname="Inconsolata",fontcolor="white",fontsize=11];
  edge[fontname="Inconsolata",fontsize=9];

  f1[label="1 [alice friend bob]"];
  f2[label="2 [bob friend charlie]"];
  f3[label="3 [alice friend dora]"];
  f4[label="4 [alice email a@b.com]"];
  is[label="subj: {alice #{1 3 4} bob #{2}",color="#cc0066"];
  ip[label="pred: {friend #{1 2 3} email #{4}",color="#cc6600"];
  io[label="obj: {bob #{1} charlie #{2} dora #{3} a@b.com #{4}",color="#0066cc"];
  f1 -> is; f1 -> ip; f1 -> io;
  f2 -> is; f2 -> ip; f2 -> io;
  f3 -> is; f3 -> ip; f3 -> io;
  f4 -> is; f4 -> ip; f4 -> io;

  q1[label="Q1: [nil friend nil]"];
  q2[label="Q2: [alice ?p ?o]"];

  sq1[label="[0 #{1 2 3 4}]",color="#cc0066"];
  pq1[label="[1 #{1 2 3}]",color="#cc6600"];
  oq1[label="[2 #{1 2 3 4}]",color="#0066cc"];

  q1res[label="#{[alice friend bob] [bob friend charlie] [alice friend dora]}"];

  is -> sq1[label="[0 nil]"];
  sq1 -> q1 -> q1res;
  ip -> pq1[label="[1 friend]"];
  pq1 -> q1;
  io -> oq1[label="[2 nil]"];
  oq1 -> q1;

  sq2[label="[0 #{1 3 4}]",color="#cc0066"];
  pq2[label="[1 #{1 2 3 4}",color="#cc6600"];

  q2res[label="#{[alice friend bob] [alice friend dora] [alice email a@b.com]}"];
  q2final[label="#{{?p friend ?o bob} {?p friend ?o dora} {?p email ?o a@b.com}}"];

  is -> sq2[label="[0 alice]"];
  sq2 -> q2 -> q2res -> q2final;
  ip -> pq2[label="[1 nil]"];
  pq2 -> q2;
  oq1 -> q2;
}
#+END_SRC

In code form this same graph could be constructed like this:

#+BEGIN_SRC clojure :tangle ../babel/examples/query-example01.cljc
  (require '[thi.ng.fabric.core :as f])
  (require '[thi.ng.fabric.facts.core :as ff])

  (def g (ff/fact-graph))
  (ff/add-fact! g '[alice friend bob])
  (ff/add-fact! g '[bob friend charlie])
  (ff/add-fact! g '[alice friend dora])
  (ff/add-fact! g '[alice email "a@b.com"])

  (def friends (ff/add-query! g '[nil friend nil] {}))
  (def alice   (ff/add-param-query! g '[alice ?p ?o] {}))

  (f/execute! (f/sync-execution-context {:graph g}))

  @friends
  ;; #{[alice friend dora] [bob friend charlie] [alice friend bob]}
  @alice
  ;; #{{?p email, ?o "a@b.com"} {?p friend, ?o bob} {?p friend, ?o dora}}
#+END_SRC

*** Index selection

#+BEGIN_SRC clojure :noweb-ref queries
  (defn index-selection
    [g sel]
    (if-let [sel (cached g ::index-sel sel)]
      (do (debug :reuse-index-sel (:sel sel)) sel)
      (let [index  ((fact-indices g) (first sel))
            vertex (f/add-vertex!
                    g nil
                    {::f/score-signal-fn f/score-signal-with-new-edges
                     ::f/collect-fn      (f/collect-pure (fn [_ in] (peek in)))})
            isel   (reify
                     IQueryResult
                     (result-vertex
                       [_] vertex)
                     f/IGraphComponent
                     (add-to-graph!
                       [_ g] _)
                     (remove-from-graph!
                       [_ g] (f/remove-from-graph! _ g nil))
                     (remove-from-graph!
                       [_ g parent]
                       (if (f/none-or-single-user? vertex parent)
                         (do (debug :remove-index-sel sel)
                             (f/disconnect-neighbor! index vertex)
                             (f/remove-vertex! g vertex)
                             true)
                         (do (f/disconnect-neighbor! vertex parent)
                             false))))]
        (f/add-edge! g index vertex signal-index-select sel)
        (cache! g ::index-sel sel isel))))

  (defn make-index-selections
    [g pattern]
    (into [] (map-indexed #(index-selection g [% %2])) pattern))
#+END_SRC

*** Basic pattern query

A basic fact query is used to match a single or multiple facts without variable bindings:

- =['alice 'friend 'bob]= only matches the stated fact
- =[nil 'friend 'bob]= matches all facts which have predicate ='friend= and object ='bob=

In general, =nil= is used as wildcard to match any S, P or O position.
Therefore, the query pattern =[nil nil nil]= matches all facts in a
triple graph (or =[nil nil nil nil]= for quads).

#+BEGIN_SRC clojure :noweb-ref queries
  (defn add-query!
    ([g pattern opts]
     (add-query! g (fact-transform g) pattern opts))
    ([g ptx pattern opts]
     (let [pattern (transform ptx pattern)]
       (if-let [q (and (empty? opts) (cached g ::queries pattern))]
         (do (debug :reuse-basic-query pattern) q)
         (let [[s p o] pattern
               sels (make-index-selections g pattern)
               acc  (f/add-vertex!
                     g {} {::f/collect-fn collect-select})
               res  (f/add-vertex!
                     g nil
                     {::f/collect-fn       (collect-basic-query-results g opts)
                      ::f/score-signal-fn  f/score-signal-with-new-edges
                      ::f/score-collect-fn (score-collect-min-signal-vals (count sels))})
               q    (reify
                      #?@(:clj
                           [clojure.lang.IDeref (deref [_] @res)]
                           :cljs
                           [IDeref (-deref [_] @res)])
                      IFactQuery
                      (raw-pattern
                        [_] pattern)
                      (query-spec
                        [_] (merge {:select :* :q [{:where pattern}]} opts))
                      IQueryResult
                      (result-vertex
                        [_] res)
                      f/IGraphComponent
                      (add-to-graph!
                        [_ g] (err/unsupported!))
                      (remove-from-graph!
                        [_ g] (f/remove-from-graph! _ g nil))
                      (remove-from-graph!
                        [_ g parent]
                        (if (f/none-or-single-user? res parent)
                          (do (debug :remove-query pattern)
                              (expire! g ::queries pattern)
                              (f/remove-vertex! g res)
                              (f/remove-vertex! g acc)
                              (run! #(f/remove-from-graph! % g acc) sels)
                              true)
                          (do (f/disconnect-neighbor! res parent)
                              false))))]
           (run! #(f/add-edge! g (result-vertex %) acc f/signal-forward nil) sels)
           (f/add-edge! g acc res f/signal-forward nil)
           (if-not (seq opts)
             (cache! g ::queries pattern q)
             q))))))
#+END_SRC

*** Parametric query

This type of query supports binding fact items to query variables.
Instead of fact triples or quads, the result set of this query
contains maps of unique variable bindings.

E.g. given the query pattern =[?s :type ?t]= and two matching facts of
=[:fabric :type :project]= and =[:alice :type :person]=, the result
set is: =#{{?s :fabric ?t :project} {?s :alice ?t :person}}=.

Use =nil= for a pattern position, if it should catch all values at
this position, but not be bound to a variable. Example: =[?s :type
nil]= will catch any facts with =:type= as predicate, but the result
set only contains unique bindings of query variable =?s=.

#+BEGIN_SRC clojure :noweb-ref queries
  (defn add-param-query!
    ([g pattern opts]
     (add-param-query! g (fact-transform g) pattern opts))
    ([g ptx pattern opts]
     (let [pattern (transform ptx pattern)]
       (if-let [q (and (empty? opts) (cached g ::queries pattern))]
         (do (debug :reuse-param-query pattern) q)
         (let [qvars?  (mapv qvar? pattern)
               raw     (mapv #(if-not (qvar? %) %) pattern)
               vmap    (bind-translator qvars? pattern)
               verify  (fact-verifier qvars? pattern)
               tx      (if verify
                         (map #(if (verify %) (vmap %)))
                         (map vmap))
               tx      (comp tx (filter identity))
               tx      (if-let [flt (:filter opts)]
                         (comp tx (filter flt))
                         tx)
               tx      (if-let [lim (:limit opts)]
                         (comp tx (take lim))
                         tx)
               coll-fn (f/collect-pure
                        (fn [_ incoming]
                          (if-let [res (seq (peek incoming))]
                            (into #{} tx res)
                            #{})))
               sub-q   (add-query! g identity-transform raw {})
               result  (f/add-vertex!
                        g nil
                        {::f/collect-fn      coll-fn
                         ::f/score-signal-fn f/score-signal-with-new-edges})
               q       (reify
                         #?@(:clj
                              [clojure.lang.IDeref (deref [_] @result)]
                              :cljs
                              [IDeref (-deref [_] @result)])
                         IFactQuery
                         (raw-pattern
                           [_] raw)
                         (query-spec
                           [_]) ;; TODO
                         IQueryResult
                         (result-vertex
                           [_] result)
                         f/IGraphComponent
                         (add-to-graph!
                           [_ g] (err/unsupported!))
                         (remove-from-graph!
                           [_ g] (f/remove-from-graph! _ g nil))
                         (remove-from-graph!
                           [_ g parent]
                           (if (f/none-or-single-user? result parent)
                             (do (debug :remove-param-query pattern)
                                 (expire! g ::queries pattern)
                                 (f/remove-vertex! g result)
                                 (f/remove-from-graph! sub-q g result)
                                 true)
                             (do (f/disconnect-neighbor! result parent)
                                 false))))]
           (f/add-edge! g (result-vertex sub-q) result f/signal-forward nil)
           (if-not (seq opts)
             (cache! g ::queries pattern q)
             q))))))
#+END_SRC

*** Query join

#+BEGIN_SRC clojure :noweb-ref queries
  (defn add-join!
    ([g lhs rhs opts]
     (add-join! g join lhs rhs opts))
    ([g join-fn lhs rhs opts]
     (let [lhs-v  (result-vertex lhs)
           rhs-v  (result-vertex rhs)
           lhs-id (f/vertex-id lhs-v)
           rhs-id (f/vertex-id rhs-v)
           tx     (if-let [flt (:filter opts)]
                    (filter flt))
           tx     (if-let [lim (:limit opts)]
                    (let [tx' (take lim)]
                      (if tx (comp tx tx') tx'))
                    tx)
           cfn    (if tx #(into #{} tx (join-fn % %2)) join-fn)
           result (f/add-vertex!
                   g nil
                   {::f/collect-fn
                    (fn [vertex]
                      (let [sig-map (f/signal-map vertex)
                            a (sig-map lhs-id)
                            b (sig-map rhs-id)]
                        (debug (f/vertex-id vertex) :join-sets a b)
                        (f/set-value! vertex (cfn a b))))
                    ::f/score-collect-fn score-collect-join
                    ::f/score-signal-fn  f/score-signal-with-new-edges})
           jq     (reify
                    #?@(:clj
                         [clojure.lang.IDeref (deref [_] @result)]
                         :cljs
                         [IDeref (-deref [_] @result)])
                    IFactQuery
                    (raw-pattern
                      [_] nil)
                    (query-spec
                      [_]) ;; TODO
                    IQueryResult
                    (result-vertex
                      [_] result)
                    f/IGraphComponent
                    (add-to-graph!
                      [_ g] (err/unsupported!))
                    (remove-from-graph!
                      [_ g] (f/remove-from-graph! _ g nil))
                    (remove-from-graph!
                      [_ g parent]
                      (if (f/none-or-single-user? result parent)
                        (do (debug :remove-query-join)
                            (f/remove-vertex! g result)
                            (f/remove-from-graph! lhs g result)
                            (f/remove-from-graph! rhs g result)
                            true)
                        (do (f/disconnect-neighbor! result parent)
                            false))))]
       (f/add-edge! g lhs-v result f/signal-forward nil)
       (f/add-edge! g rhs-v result f/signal-forward nil)
       jq)))

  (defn add-query-join!
    ([g patterns opts]
     (add-query-join! g (fact-transform g) patterns opts))
    ([g ptx patterns opts]
     (let [[a b & more :as p] patterns ;;(sort-patterns patterns)
           _  (assert (and a b) "Requires min. 2 query patterns")
           jq (reduce
               #(add-join! g join % (add-param-query! g ptx %2 {}) {})
               (add-join!
                g join
                (add-param-query! g ptx a {})
                (add-param-query! g ptx b {})
                (if (< 1 (count more)) {} opts))
               (butlast more))]
       (if-let [p (last more)]
         (add-join! g join jq (add-param-query! g ptx p {}) opts)
         jq))))

  (defn add-query-join-optional!
    ([g patterns opts]
     (add-query-join-optional! g (fact-transform g) patterns opts))
    ([g ptx patterns opts]
     (let [[a b & more] patterns
           _  (assert (and a b) "Requires min. 2 query patterns")
           jq (reduce
               #(add-join! g join-optional % (add-param-query! g ptx %2 {}) {})
               (add-join!
                g join-optional
                (add-param-query! g ptx a {})
                (add-param-query! g ptx b {})
                (if (< 1 (count more)) {} opts))
               (butlast more))]
       (if-let [p (last more)]
         (add-join! g join-optional jq (add-param-query! g ptx p {}) opts)
         jq))))
#+END_SRC

*** Query union

#+BEGIN_SRC clojure :noweb-ref queries
  (defn add-query-union!
    [g queries opts]
    (assert (< 1 (count queries)) "min. 2 queries required")
    (let [tx  (if-let [flt (:filter opts)]
                (filter flt))
          tx  (if-let [lim (:limit opts)]
                (let [tx' (take lim)]
                  (if tx (comp tx tx') tx'))
                tx)
          res (f/add-vertex!
               g nil
               {::f/collect-fn
                (fn [vertex]
                  (let [subs (vals (f/signal-map vertex))
                        res  (reduce #(if (seq %2) (into % %2) %) subs)]
                    (f/set-value! vertex (if tx (into #{} tx res) res))))
                ::f/score-signal-fn f/score-signal-with-new-edges})
          q   (reify
                #?@(:clj
                     [clojure.lang.IDeref (deref [_] @res)]
                     :cljs
                     [IDeref (-deref [_] @res)])
                IFactQuery
                (raw-pattern
                  [_] nil)
                (query-spec
                  [_]) ;; TODO
                IQueryResult
                (result-vertex
                  [_] res)
                f/IGraphComponent
                (add-to-graph!
                  [_ g] (err/unsupported!))
                (remove-from-graph!
                  [_ g] (f/remove-from-graph! _ g nil))
                (remove-from-graph!
                  [_ g parent]
                  (if (f/none-or-single-user? res parent)
                    (do (debug :remove-query-union)
                        (f/remove-vertex! g res)
                        (run! #(f/remove-from-graph! % g res) queries)
                        true)
                    (do (f/disconnect-neighbor! res parent)
                        false))))]
      (run! #(f/add-edge! g (result-vertex %) res f/signal-forward nil) queries)
      q))
#+END_SRC

*** Path queries

A property path is a possible route through a graph between two nodes.
The most trivial case, a single fact, has a path length of 1. The
ends of the path may be constants or variables. Variables can not be
used as part of the path (predicates) itself, only at the ends.

Path queries allow for more concise expressions for some graph
patterns and they also add the ability to match connectivity of
subjects/objects by an arbitrary length path.

*Note:* Currently, path queries are only supported for triples (fact
len = 3) and only bounded path queries are implemented, meaning both
min/max path lengths MUST be specified.

**** Bounded path query

#+BEGIN_SRC clojure
  ;; match path (of single pred) between depth 1 and 3
  (add-path-query! g '[?s [pred] ?o] 1 3)

  ;; match path (cyclically repeated) between 2 hops 4
  (add-path-query! g '[?s [pred1 pred2] ?o] 2 4)

  ;; math given path
  (add-path-query! g '[?s [p1 p2 p3] ?o])

  ;; match *any* paths starting at "node-a" with len 2 - 4
  (add-path-query! g '[node-a [nil] ?o] 1 4)

  ;; check if path exists between fixed subject/object
  ;; this query has no variables, see note below
  (add-path-query! g '[node-a [pred] node-b] 3 3)
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref queries
  (defn add-path-query!
    ([g path-pattern]
     (let [len (count (nth path-pattern 1))]
       (add-path-query! g path-pattern len len)))
    ([g path-pattern mind maxd]
     (add-path-query! g (fact-transform g) path-pattern mind maxd))
    ([g ptx path-pattern mind maxd]
     (assert (pos? mind) "min depth must be >= 1")
     (assert (<= mind maxd) "min depth must be <= max depth")
     (let [[patterns avars] (resolve-path-pattern path-pattern maxd)
           [?s _ ?o] path-pattern
           vs? (qvar? ?s)
           vo? (qvar? ?o)
           req (take mind patterns)
           opt (drop mind (take maxd patterns))
           req (if (seq req)
                 (if (== 1 (count req))
                   (add-param-query! g ptx (first req) {})
                   (add-query-join! g ptx req {})))
           opt (if (seq opt)
                 (if (== 1 (count opt))
                   (add-param-query! g ptx (first opt) {})
                   (add-query-join-optional! g ptx opt {})))
           q   (if (and req opt)
                 (add-join! g join-optional req opt {}) ;; TODO opts
                 (or req opt))
           tx  (cond
                 (or (= mind maxd) (and vs? (not vo?)))
                 (let [qv (filter qvar? path-pattern)]
                   (map #(select-keys* % qv)))

                 (and vo? (not vs?))
                 (let [rv (take (dec mind) avars)]
                   (mapcat #(map (fn [v] {?o v}) (vals (apply dissoc % rv)))))

                 :else
                 (let [rv (cons ?s (take (dec mind) avars))]
                   (mapcat
                    #(let [s (% ?s)] (map (fn [v] {?s s ?o v}) (vals (apply dissoc % rv)))))))
           res (f/add-vertex!
                g #{}
                {::f/collect-fn (f/collect-pure (fn [_ in] (into #{} tx (peek in))))})
           pq  (reify
                 #?@(:clj
                      [clojure.lang.IDeref (deref [_] @res)]
                      :cljs
                      [IDeref (-deref [_] @res)])
                 IFactQuery
                 (raw-pattern
                   [_] nil)
                 (query-spec
                   [_]) ;; TODO
                 IQueryResult
                 (result-vertex
                   [_] res)
                 f/IGraphComponent
                 (add-to-graph!
                   [_ g] (err/unsupported!))
                 (remove-from-graph!
                   [_ g] (f/remove-from-graph! _ g nil))
                 (remove-from-graph!
                   [_ g parent]
                   (if (f/none-or-single-user? res parent)
                     (do (debug :remove-path-query)
                         (f/remove-vertex! g res)
                         (f/remove-from-graph! q g res)
                         true)
                     (do (f/disconnect-neighbor! res parent)
                         false))))]
       (f/add-edge! g (result-vertex q) res f/signal-forward nil)
       pq)))
#+END_SRC

*** TODO Query result modifiers

TODO add reify

#+BEGIN_SRC clojure :noweb-ref queries
  (defn add-qvar-selection!
    [g select result]
    (if (= :* select)
      result
      (let [select (if (sequential? select) select [select])
            tx     (comp (map #(select-keys % select)) (filter seq))
            vertex (f/add-vertex!
                    g nil
                    {::f/collect-fn      (collect-into-set tx)
                     ::f/score-signal-fn f/score-signal-with-new-edges})]
        (f/add-edge! g (result-vertex result) vertex f/signal-forward nil)
        vertex)))

  (defn add-query-filter!
    [g flt q]
    (let [res (f/add-vertex!
               g nil
               {::f/collect-fn      (collect-into-set (filter flt))
                ::f/score-signal-fn f/score-signal-with-new-edges})]
      (f/add-edge! g (result-vertex q) res f/signal-forward nil)
      res))

  (defn add-query-group-by!
    [g gfn q]
    (let [res (f/add-vertex!
               g nil
               {::f/collect-fn      (f/collect-pure (fn [_ in] (group-by gfn (peek in))))
                ::f/score-signal-fn f/score-signal-with-new-edges})]
      (f/add-edge! g (result-vertex q) res f/signal-forward nil)
      res))

  (defn add-counter!
    [g src]
    (let [v (f/add-vertex!
             g nil
             {::f/collect-fn      (f/collect-pure (fn [_ in] (count (peek in))))
              ::f/score-signal-fn f/score-signal-with-new-edges})]
      (f/add-edge! g src v f/signal-forward nil)
      v))
#+END_SRC

*** Query helpers

#+BEGIN_SRC clojure :noweb-ref query-helpers
  (def ^:dynamic *auto-qvar-prefix* "?__q")

  (defn- qvar?
    "Returns true, if x is a qvar (a symbol prefixed with '?')"
    [x] (and (symbol? x) (= \? (.charAt ^String (name x) 0))))

  (defn auto-qvar?
    "Returns true, if x is an auto-generated qvar
    (a symbol prefixed with *auto-qvar-prefix*)"
    [x] (and (symbol? x) (zero? (.indexOf ^String (name x) ^String *auto-qvar-prefix*))))

  (defn auto-qvar
    "Creates a new auto-named qvar (symbol)."
    [] (gensym *auto-qvar-prefix*))

  (defn qvar-name
    [x] (-> x name (subs 1)))

  (defn resolve-path-pattern
    "Takes a path triple pattern and max depth. The pattern's predicate
    must be a seq of preds. Returns a 2-elem vector [patterns vars],
    where `patterns` is a seq of query patterns with injected temp qvars
    for inbetween patterns and `vars` the autogenerated qvars themselves.
    Example:

        [?s [p1 p2 p3] ?o]
        => [([?s p1 ?__q0] [?__q0 p2 ?__q1] [?__q1 p3 ?o]) (?__q0 ?__q1)]"
    [[s p o] maxd]
    (let [avars (repeatedly maxd auto-qvar)
          vars  (cons s avars)]
      [(->> (concat (interleave vars (take maxd (cycle p))) [o])
            (partition 3 2))
       avars]))

  (defn pattern-var-count
    [pattern]
    (count (filter qvar? pattern)))

  (defn sort-patterns
    [patterns]
    (sort-by pattern-var-count patterns))

  (defn select-keys*
    "Like c.c/select-keys, but doesn't retain map's meta"
    {:static true}
    [map keyseq]
    (loop [ret {} keys (seq keyseq)]
      (if keys
        #?(:clj
           (let [entry (. clojure.lang.RT (find map (first keys)))]
             (recur
              (if entry (conj ret entry) ret)
              (next keys)))
           :cljs
           (let [key   (first keys)
                 entry (get map key ::not-found)]
             (recur
              (if (= entry ::not-found) ret (assoc ret key entry))
              (next keys))))
        ret)))

  (defn index*
    "Like clojure.set/index, but using select-keys w/o metadata retention."
    [xrel ks]
    (persistent!
     (reduce
      (fn [m x]
        (let [ik (select-keys* x ks)]
          (assoc! m ik (conj (get m ik #{}) x))))
      (transient {}) xrel)))

  (defn join
    "Based on clojure.set/join. Does not join when there're no shared
    keys and no key mapping, enforced result set limit, uses transients."
    [xrel yrel]
    (if (and (seq xrel) (seq yrel))
      (let [ks (set/intersection (set (keys (first xrel))) (set (keys (first yrel))))]
        (if (seq ks)
          (let [[r s] (if (<= (count xrel) (count yrel))
                        [xrel yrel]
                        [yrel xrel])
                idx (index* r ks)] 
            (persistent!
             (reduce
              (fn [ret x]
                (let [found (idx (select-keys* x ks))]
                  (if found
                    (reduce #(conj! % (conj %2 x)) ret found)
                    ret)))
              (transient #{}) s)))
          #{}))
      #{}))

  (defn join-optional
    [a b]
    (loop [old (transient #{}), new (transient #{}), kb b]
      (if kb
        (let [kb'       [(first kb)]
              [old new] (loop [old old, new new, ka a]
                          (if ka
                            (let [ka' (first ka)
                                  j   (first (join [ka'] kb'))]
                              (if j
                                (recur (conj! old ka') (conj! new j) (next ka))
                                (recur old new (next ka))))
                            [old new]))]
          (recur old new (next kb)))
        (let [new (persistent! new)]
          (if (seq new)
            (into (apply disj (set a) (persistent! old)) new)
            a)))))
#+END_SRC

**** Variable bindings injection multi-method

This function (and =fact-verifier= below) are used as an extensible
mechanism to allow the graph to support facts of varying lengths and
queries over them. Currently, this module only supports fact triples
(len=3) or quads (len=4).

=bind-translator= is used to provide optimized functions to bind query
variables to their fact components in the result set of a parametric
query.

#+BEGIN_SRC clojure :noweb-ref query-helpers
  (defmulti bind-translator
    (fn [qvars? pattern] (count pattern)))

  (defmethod bind-translator 3
    [[vs? vp? vo?] [s p o]]
    (if vs?
      (if vp?
        (if vo?
          (fn [r] {s (r 0) p (r 1) o (r 2)})
          (fn [r] {s (r 0) p (r 1)}))
        (if vo?
          (fn [r] {s (r 0) o (r 2)})
          (fn [r] {s (r 0)})))
      (if vp?
        (if vo?
          (fn [r] {p (r 1) o (r 2)})
          (fn [r] {p (r 1)}))
        (if vo?
          (fn [r] {o (r 2)})
          (fn [_] {})))))

  (defmethod bind-translator 4
    [[vt? vs? vp? vo?] [t s p o]]
    (if vt?
      (if vs?
        (if vp?
          (if vo?
            (fn [r] {t (r 0) s (r 1) p (r 2) o (r 3)})
            (fn [r] {t (r 0) s (r 1) p (r 2)}))
          (if vo?
            (fn [r] {t (r 0) s (r 1) o (r 3)})
            (fn [r] {t (r 0) s (r 1)})))
        (if vp?
          (if vo?
            (fn [r] {t (r 0) p (r 2) o (r 3)})
            (fn [r] {t (r 0) p (r 2)}))
          (if vo?
            (fn [r] {t (r 0) o (r 3)})
            (fn [r] {t (r 0)}))))
      (if vs?
        (if vp?
          (if vo?
            (fn [r] {s (r 1) p (r 2) o (r 3)})
            (fn [r] {s (r 1) p (r 2)}))
          (if vo?
            (fn [r] {s (r 1) o (r 3)})
            (fn [r] {s (r 1)})))
        (if vp?
          (if vo?
            (fn [r] {p (r 2) o (r 3)})
            (fn [r] {p (r 2)}))
          (if vo?
            (fn [r] {o (r 3)})
            (fn [_] {}))))))
#+END_SRC

**** Fact verifier multi-method

The fact verifier function is used to provide optimized validations to
ensure query variables are bound to unique values. E.g. given a query
pattern =['?a ?b '?a]=, these functions ensure that all 3 qvars are
bound to different values, i.e. it would reject the fact =[fact is
fiction]= (yes, pretty meaningless..) because =?a= wouldn't be bound to the
same values (first =?a= binds to "fact", second =?a= to "fiction")...

#+BEGIN_SRC clojure
((fact-verifier [true true true] '[?a ?b ?a]) '[fact is fiction])
;; false
((fact-verifier [true true true] '[?a ?b ?a]) '[fact is fact])
;; true
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref query-helpers
  (defmulti fact-verifier
    (fn [qvars? pattern] (count pattern)))

  (defmethod fact-verifier 3
    [[vs? vp? vo?] [s p o]]
    (cond
      (and vs? vp? vo?) (cond
                          (= s p o) #(= (% 0) (% 1) (% 2))
                          (= s p) #(and (= (% 0) (% 1)) (not= (% 0) (% 2)))
                          (= s o) #(and (= (% 0) (% 2)) (not= (% 0) (% 1)))
                          (= p o) #(and (= (% 1) (% 2)) (not= (% 0) (% 1)))
                          :else nil)
      (and vs? vp?)     (if (= s p) #(= (% 0) (% 1)) #(not= (% 0) (% 1)))
      (and vs? vo?)     (if (= s o) #(= (% 0) (% 2)) #(not= (% 0) (% 2)))
      (and vp? vo?)     (if (= p o) #(= (% 1) (% 2)) #(not= (% 1) (% 2)))
      :else             nil))

  (defmethod fact-verifier 4
    [[vt? vs? vp? vo?] [t s p o]]
    (cond
      (and vt? vs? vp? vo?)
      (cond
        (= t s p o)           #(= (% 0) (% 1) (% 2) (% 3))
        (= t s p)             #(and (not= (% 0) (% 3)) (= (% 0) (% 1) (% 2)))
        (= t s o)             #(and (not= (% 0) (% 2)) (= (% 0) (% 1) (% 3)))
        (= t p o)             #(and (not= (% 0) (% 1)) (= (% 0) (% 2) (% 3)))
        (= s p o)             #(and (not= (% 0) (% 1)) (= (% 1) (% 2) (% 3)))
        (and (= t s) (= p o)) #(and (= (% 0) (% 1)) (= (% 2) (% 3)))
        (and (= t p) (= s o)) #(and (= (% 0) (% 2)) (= (% 1) (% 3)))
        (and (= t o) (= s p)) #(and (= (% 0) (% 3)) (= (% 1) (% 2)))
        (= t s)               #(let [t (first %)] (and (= t (% 1)) (not= t (% 2)) (not= t (% 3))))
        (= t p)               #(let [t (first %)] (and (= t (% 2)) (not= t (% 1)) (not= t (% 3))))
        (= t o)               #(let [o (peek %)]  (and (= o (% 0)) (not= o (% 1)) (not= o (% 2))))
        (= s p)               #(let [s (nth % 1)] (and (= s (% 2)) (not= s (% 3)) (not= s (% 0))))
        (= s o)               #(let [o (peek %)]  (and (= o (% 1)) (not= o (% 2)) (not= o (% 0))))
        (= p o)               #(let [o (peek %)]  (and (= o (% 2)) (not= o (% 1)) (not= o (% 0))))
        :else                 nil)
      (and vt? vs? vp?)
      (cond
        (= t s p)             #(= (% 0) (% 1) (% 2))
        (= t s)               #(and (= (% 0) (% 1)) (not= (% 0) (% 2)))
        (= t p)               #(and (= (% 0) (% 2)) (not= (% 0) (% 1)))
        (= s p)               #(and (= (% 1) (% 2)) (not= (% 1) (% 0)))
        :else                 nil)
      (and vt? vs? vo?)
      (cond
        (= t s o)             #(= (% 0) (% 1) (% 3))
        (= t s)               #(and (= (% 0) (% 1)) (not= (% 0) (% 3)))
        (= t o)               #(and (= (% 0) (% 3)) (not= (% 0) (% 1)))
        (= s o)               #(and (= (% 1) (% 3)) (not= (% 1) (% 0)))
        :else                 nil)
      (and vt? vp? vo?)
      (cond
        (= t p o)             #(= (% 0) (% 2) (% 3))
        (= t p)               #(and (= (% 0) (% 2)) (not= (% 0) (% 3)))
        (= t o)               #(and (= (% 0) (% 3)) (not= (% 0) (% 1)))
        (= p o)               #(and (= (% 2) (% 3)) (not= (% 2) (% 0)))
        :else                 nil)
      (and vs? vp? vo?)
      (cond
        (= s p o)             #(= (% 1) (% 2) (% 3))
        (= s p)               #(and (= (% 1) (% 2)) (not= (% 1) (% 3)))
        (= s o)               #(and (= (% 1) (% 3)) (not= (% 1) (% 2)))
        (= p o)               #(and (= (% 2) (% 3)) (not= (% 2) (% 1)))
        :else                 nil)
      (and vt? vs?)           (if (= t s) #(= (% 0) (% 1)) #(not= (% 0) (% 1)))
      (and vt? vp?)           (if (= t p) #(= (% 0) (% 2)) #(not= (% 0) (% 2)))
      (and vt? vo?)           (if (= t o) #(= (% 0) (% 3)) #(not= (% 0) (% 3)))
      (and vs? vp?)           (if (= s p) #(= (% 1) (% 2)) #(not= (% 1) (% 2)))
      (and vs? vo?)           (if (= s o) #(= (% 1) (% 3)) #(not= (% 1) (% 3)))
      (and vp? vo?)           (if (= p o) #(= (% 2) (% 3)) #(not= (% 2) (% 3)))
      :else                   nil))
#+END_SRC

** Rulebased inference

#+BEGIN_SRC clojure :noweb-ref inference
  (defn add-rule!
    [g {:keys [id query patterns transform production collect-fn] :as opts}]
    (let [id      (or id (f/random-id))
          coll-fn (or collect-fn (collect-inference g production))
          query   (or query
                      (let [tx (or transform (fact-transform g))
                            q-opts (select-keys opts [:filter :limit])]
                        (if (< 1 (count patterns))
                          (add-query-join! g tx patterns q-opts)
                          (add-param-query! g tx (first patterns) q-opts))))
          inf     (f/add-vertex! g #{} {::f/collect-fn coll-fn})
          rule    (reify
                    #?@(:clj
                         [clojure.lang.IDeref (deref [_] @query)]
                         :cljs
                         [IDeref (-deref [_] @query)])
                    IFactQuery
                    (raw-pattern
                      [_] nil)
                    (query-spec
                      [_]) ;; TODO
                    IQueryResult
                    (result-vertex
                      [_] (result-vertex query))
                    f/IGraphComponent
                    (add-to-graph!
                      [_ g] (err/unsupported!))
                    (remove-from-graph!
                      [_ g] (f/remove-from-graph! _ g nil))
                    (remove-from-graph!
                      [_ g parent]
                      (if (f/none-or-single-user? inf parent)
                        (do (debug :remove-rule id)
                            (f/remove-vertex! g inf)
                            (f/remove-from-graph! query g inf)
                            true)
                        (do (f/disconnect-neighbor! inf parent)
                            false))))]
      (f/add-edge! g (result-vertex query) inf f/signal-forward nil)
      (cache! g ::rules id rule)))
#+END_SRC

** Signal & collect functions

#+BEGIN_SRC clojure :noweb-ref sig-coll
  (defn- signal-fact
    [vertex op] [op (f/vertex-id vertex) @vertex])

  (defn- collect-index
    [spo]
    (let [tx (map (fn [[op id t]] [op id (nth t spo)]))
          rf (completing
              (fn [acc [op id x]]
                (case op
                  :add    (assoc acc x (conj (or (acc x) #{}) id))
                  :remove (if-let [idx (acc x)]
                            (if (= #{id} idx)
                              (dissoc acc x)
                              (assoc acc x (disj idx id)))
                            acc)
                  (do (warn "ignoring unknown index signal op:" op)
                      acc))))]
      (f/collect-pure
       (fn [val incoming]
         ;;(debug :old-index val)
         (let [val (transduce tx rf val incoming)]
           ;;(debug :new-index val)
           val)))))

  (defn- signal-index-select
    [vertex [idx sel]]
    [idx (if sel (@vertex sel [nil]) (->> @vertex vals (mapcat identity) (set)))])

  (def ^:private collect-select
    (f/collect-pure
     (fn [val incoming]
       (let [val (reduce (fn [acc [idx res]] (assoc acc idx res)) val incoming)]
         ;;(debug :coll-select val incoming)
         val))))

  (defn- score-collect-min-signal-vals
    [num]
    (fn [vertex]
      (if (> num (count (vals (peek (f/uncollected-signals vertex))))) 0 1)))

  (defn- score-collect-min-signals
    [num]
    (fn [vertex]
      (if (> num (count (f/uncollected-signals vertex))) 0 1)))

  (defn- collect-basic-query-results
    [g opts]
    (let [ftx (fact-transform g)
          tx  (map #(untransform ftx @(f/vertex-for-id g %)))
          tx  (if-let [flt (:filter opts)]
                (comp tx (filter flt))
                tx)
          tx  (if-let [lim (:limit opts)]
                (comp tx (take lim))
                tx)]
      (f/collect-pure
       (fn [_ incoming]
         (let [res (vals (peek incoming))]
           ;;(debug :agg-incoming res)
           (if (every? #(not= [nil] %) res)
             (->> res
                  (into #{} (map #(disj % nil)))
                  (sort-by count)
                  (reduce set/intersection)
                  (into #{} tx))
             #{}))))))

  (defn- score-collect-join
    [vertex]
    (if (and (seq (f/uncollected-signals vertex))
             (== (count (f/signal-map vertex)) 2))
      1 0))

  (defn- collect-inference
    [g production]
    (fn [vertex]
      (let [prev @vertex
            in   (reduce into #{} (f/uncollected-signals vertex))
            adds (set/difference in prev)]
        (debug (f/vertex-id vertex) :additions adds)
        (run! #(production g vertex %) adds)
        (f/update-value! vertex #(set/union % adds)))))

  (defn collect-into-set
    [tx] (f/collect-pure (fn [_ in] (into #{} tx (peek in)))))
#+END_SRC

** Graph logging

#+BEGIN_SRC clojure :noweb-ref logger
  (def fact-log-transducer
    (comp
     (filter (fn [[op v]] (and (#{:add-vertex :remove-vertex} op) (vector? @v))))
     (map (fn [[op v]] [({:add-vertex :+ :remove-vertex :-} op) @v]))))

  (defn add-fact-graph-logger
    [g log-fn]
    (let [ch        (chan 1024 fact-log-transducer)
          watch-id  (f/random-id)
          log->chan #(go (>! ch %))]
      (go-loop []
        (let [t (<! ch)]
          (when t
            (log-fn t)
            (recur))))
      (f/add-watch! g :add-vertex watch-id log->chan)
      (f/add-watch! g :remove-vertex watch-id log->chan)
      {:graph g :chan ch :watch-id watch-id}))

  (defn remove-fact-graph-logger
    [{:keys [graph watch-id chan]}]
    (f/remove-watch! graph :add-vertex watch-id)
    (f/remove-watch! graph :remove-vertex watch-id)
    (close! chan))
#+END_SRC

** Generic helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/fabric/facts/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.fabric.facts.core
    #?@(:clj
        [(:require
          [thi.ng.fabric.core :as f]
          [thi.ng.xerror.core :as err]
          [clojure.set :as set]
          [clojure.data.int-map :as imap]
          [clojure.core.async :as a :refer [go go-loop chan close! <! >! alts! timeout]]
          [taoensso.timbre :refer [debug info warn]])]
        :cljs
        [(:require-macros
          [cljs.core.async.macros :refer [go go-loop]]
          [cljs-log.core :refer [debug info warn]])
         (:require
          [thi.ng.fabric.core :as f]
          [thi.ng.xerror.core :as err]
          [clojure.set :as set]
          [cljs.core.async :refer [chan close! <! >! alts! timeout]])]))

  (def ^:private MAX_LIMIT #?(:clj Long/MAX_VALUE :cljs (.-MAX_VALUE js/Number)))

  (declare index-selection make-index-selections qvar? add-query! add-query-join!)

  <<protos>>

  <<helpers>>

  <<sig-coll>>

  <<query-helpers>>

  <<fact-v>>

  <<index-v>>

  <<fact-tx>>

  <<graph>>

  <<queries>>

  <<inference>>

  <<logger>>
#+END_SRC

** TODO Questions

*** maps as facts?

- maybe more convenient, but not strictly facts
- requires custom fact transforms & query patterns (also maps)
- how to deal with adding new facts, merged into original map?
  - just provide map translations: map->facts (use trio triple-seq conversion)

#+BEGIN_SRC clojure
  ;; example map
  {"P-123" {:name "karsten" :nick "toxi" :address {:country "uk", :city "london"}}}

  ;; query: subjects with name & city
  {?n :name ?city [:address :city]}
#+END_SRC
