#+SETUPFILE: ../../common/setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingfabricfactsdsl][Namespace: thi.ng.fabric.facts.dsl]]
     - [[#introduction][Introduction]]
     - [[#public-api][Public API]]
     - [[#todo-examples][TODO Examples]]
     - [[#query-specification][Query specification]]
         - [[#sub-query-types][Sub-query types]]
         - [[#sub-query-modifiers][Sub-query modifiers]]
     - [[#implementation][Implementation]]
     - [[#expressions][Expressions]]
         - [[#aggregation-expressions][Aggregation expressions]]
         - [[#grouping-expressions][Grouping expressions]]
     - [[#helper-functions][Helper functions]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.fabric.facts.dsl

** Introduction

Whilst the query vertex tree functionality provided by the
/facts-core/ module is powerful, it's somewhat "low-level", imperative
and verbose to use. Therefore, this namespace provides a more
userfriendly, succinct "high level" layer to construct query trees in
a completely declarative way and exposes further functionality, like
an expression language to define result filters, query variable
projection, aggregations, sorting etc.

The query spec DSL is highly inspired by the W3C SPARQL language,
albeit expressed in a more Clojuresque way and not limited to RDF
semantics.

Query specs are described as standard Clojure maps and therefore offer
all the usual benefits including composability, EDN serialization. The
latter therefore also allows query specs to be stored in the graphs as
part of facts and then be able to define queries returning query specs
(e.g. for UI templating/widgets), thus enabling a completely dynamic
and datadriven approach to design applications.

The expression language is extensible via its multi-method
implementation. See [[#expressions][section]] further below for details.

** Public API

The only public part of this namespace consists of this single function:

#+BEGIN_SRC clojure :noweb-ref dsl-public
  (defn add-query-from-spec!
    [g spec]
    (-> (compile-query g spec)
        (compile-select-qvars g spec)))
#+END_SRC

** TODO Examples

Lots more examples can be found in the [[../test/core.org][test]] namespace for this module.
For a general overview of query patterns and supported query types,
please also see the [[core.org#queries][Queries]] section in the =thi.ng.fabric.facts.core=
namespace.

#+BEGIN_SRC clojure
  (dsl/add-query-from-spec!
   graph
   '{:select    [?res ?type ...]
     :q         [{:where [[?res :title ?t] [?res :type ?type]]}
                 {:optional [[?res :schema ?schema]]}]
     :filter    (or (= ?res :toxi) (= ?type :person))
     :group-by  [?type ?res]
     :aggregate {?num (agg-count)}
     :order     ?type})
#+END_SRC

** Query specification

A query spec map can have the following toplevel keys:

| *Key*        | *Required?* | *Value*                        | *Description*                                    |
|--------------+-------------+--------------------------------+--------------------------------------------------|
| =:q=         | Y           | Vector                         | Vector of sub-query maps (see below)             |
| =:select=    | N           | qvar or qvar vec               | List qvars to be projected into result set       |
| =:filter=    | N           | fn or DSL expression           | Filter criteria for result set                   |
| =:order=     | N           | fn, qvar, qvar vec or DSL expr | Sorting criteria for result set                  |
| =:group-by=  | N           | fn, qvar, qvar vec or DSL expr | Grouping criteria for results, causes result map |
| =:aggregate= | N           | fn or DSL aggregation expr     | Inject new qvars w/ reduced values               |
| =:limit=     | N           | Positive int                   | Limit the number of results to N items           |

*** Sub-query types

The DSL supports the following sub-query types. Each type (apart from
=:path=) takes a number of query patterns and always computes their
joined result set. The sub-query types only differ in how each
sub-queries results are merged with others.

**** :where - join queries

Standard join with other sub-query results.

#+BEGIN_SRC clojure
  ;; match any two people knowing eachother
  ;; but only if we know both of their nicknames too
  {:q [{:where [[?a knows ?b]
                [?a nickname ?anick]
                [?b nickname ?bnick]]}]}
#+END_SRC

**** :optional - optional join queries

Optional join with other sub-query results. Since on the RHS is the
optional part in this join type, this type should *not* be used as
first sub-query in a main spec.

Examples:

#+BEGIN_SRC clojure
  ;; match people acquaintances
  ;; optionally match 1st person's nickname and/or age
  {:q [{:where [[?a knows ?b]]}
       {:optional [[?a nickname ?nick]]}
       {:optional [[?a age ?age]]}]}
#+END_SRC

*Important:* Note the use of two separate =:optional= sub-queries. If
both the optional =?nick= and =?age= where part of the same sub-query,
then only =?a='s with *both* =?nick= and =?age= would be matched. By
keeping them separate, this query will also match =?a='s with only
=?nick= *or* =?age= values.

**** :union - query unions

A query union simply merges its own result maps with that of other
sub-queries. This query type too should *not* be used as first
sub-query in a main spec.

*Important:* This type is only meant to merge distinct result sets
without any shared qvars!

Examples:

#+BEGIN_SRC clojure
  ;; return any "knowing" and friend relationships
  {:q [{:where [[?a knows ?b]]}
       {:union [[?e friend ?f]]}]}
#+END_SRC

**** :path - bounded path queries

A sub-query of this type takes a single path query pattern and options
map defining accepted path lengths:

Examples:

#+BEGIN_SRC clojure
  ;; match grandparent rels
  {:q [{:path [?gp [parent-of parent-of] ?gc]}]}

  ;; match ancestor rels w/ path lens 2-4
  {:q [{:path [?a [parent-of] ?b] :min 2 :max 4}]}

  ;; match friends of children (and optionally their friends)
  {:q [{:path [?p [parent-of friend friend] ?f] :min 2 :max 3}]}
#+END_SRC

*** Sub-query modifiers

- =:filter= - same as top-level filter expression, but only applying
  to this sub-query
- =:limit= - limit a sub-query's result set to N items
- =:select= - select qvars to be projected into result set. This is
  useful for large join queries w/ various intermediate qvars, not
  required to be retained outside the sub-query. Use of this feature
  will have a positive impact on down-stream joins and other result
  processing performance.

** Implementation

#+BEGIN_SRC clojure :noweb-ref dsl
  (defn compile-query-filter
    [flt] (if (fn? flt) flt (compile-expr flt)))

  (defn compile-result-order
    [order]
    (if (fn? order)
      order
      (if (sequential? order)
        (fn [r] (reduce #(conj % (get r %2)) [] order))
        (fn [r] (get r order)))))

  (defn compile-result-aggregation
    [agg]
    (let [agg (reduce-kv
               (fn [acc k v] (assoc acc k (compile-expr v)))
               {} agg)]
      (fn [results]
        (reduce-kv
         (fn [acc k afn]
           (assoc acc k (afn results)))
         {} agg))))

  (defn compile-result-grouping
    [group]
    (if (fn? group)
      group
      (cond
        (and (sequential? group) (every? ff/qvar? group))
        (fn [r] (reduce #(conj % (get r %2)) [] group))

        (ff/qvar? group)
        (fn [r] (get r group))

        :else
        (compile-expr group))))

  (defn sub-query-options
    [opts]
    (-> opts
        (select-keys [:filter :limit :select])
        (update :filter #(if % (compile-query-filter %)))))

  (defmulti compile-sub-query
    (fn [g parent q spec] (some #{:where :optional :union :path} (keys q))))

  (defmethod compile-sub-query :where
    [g parent q spec]
    (let [pat  (:where q)
          opts (sub-query-options q)
          q    (if (< 1 (count pat))
                 (ff/add-query-join! g (:transform spec) pat opts)
                 (ff/add-param-query! g (:transform spec) (first pat) opts))]
      (if parent
        (ff/add-join! g parent q {})
        q)))

  (defmethod compile-sub-query :optional
    [g parent q spec]
    (let [pat  (:optional q)
          opts (sub-query-options q)
          q    (if (< 1 (count pat))
                 (ff/add-query-join! g (:transform spec) pat opts)
                 (ff/add-param-query! g (:transform spec) (first pat) opts))]
      (if parent
        (ff/add-join! g ff/join-optional parent q {})
        q)))

  (defmethod compile-sub-query :union
    [g parent q spec]
    (let [pat  (:union q)
          opts (sub-query-options q)
          q    (if (< 1 (count pat))
                 (ff/add-query-join! g (:transform spec) pat opts)
                 (ff/add-param-query! g (:transform spec) (first pat) opts))]
      (if parent
        (ff/add-query-union! g [parent q] {})
        q)))

  (defmethod compile-sub-query :path
    [g parent q spec]
    (let [opts (merge (select-keys q [:min :max]) (sub-query-options q))
          q    (ff/add-path-query! g (:transform spec) (:path q) opts)]
      (if parent
        (ff/add-join! g parent q {})
        q)))

  (defn compile-query
    [g {:keys [q] :as spec}]
    (let [spec (update spec :transform #(or % (ff/fact-transform g)))]
      (reduce
       (fn [acc sq] (compile-sub-query g acc sq spec))
       (compile-sub-query g nil (first q) spec)
       (rest q))))

  (defn compile-select-qvars
    [result g spec]
    (let [spec (cond-> spec
                 (:filter spec)    (update :filter compile-query-filter)
                 (:order spec)     (update :order compile-result-order)
                 (:group-by spec)  (update :group-by compile-result-grouping)
                 (:aggregate spec) (-> (assoc :aggregate* (:aggregate spec))
                                       (update :aggregate compile-result-aggregation)))]
      (ff/add-query-result! g spec result)))
#+END_SRC

** Expressions

#+BEGIN_SRC clojure :noweb-ref expr
  (def vararg-ops
    {'+    [number? +]
     '-    [number? -]
     '*    [number? *]
     '/    [number? /]
     '=    [nil =]
     'not= [nil not=]
     'str  [nil str]})

  (def unary-ops
    {'not   [nil not]
     'int   [number? int]
     'float [number? double]
     'abs   [number? #(Math/abs %)]
     'sqrt  [number? #(Math/sqrt %)]
     'exp   [number? #(Math/exp %)]
     'sin   [number? #(Math/sin %)]
     'asin  [number? #(Math/asin %)]
     'cos   [number? #(Math/cos %)]
     'acos  [number? #(Math/acos %)]
     'tan   [number? #(Math/tan %)]
     'atan  [number? #(Math/atan %)]
     'floor [number? #(long (Math/floor %))]
     'ceil  [number? #(long (Math/ceil %))]
     'round [number? #(Math/round (double %))]})

  (def binary-ops
    {'<     [nil nil #(neg? (compare % %2))]
     '>     [nil nil #(pos? (compare % %2))]
     '<=    [nil nil #(<= (compare % %2) 0)]
     '>=    [nil nil #(>= (compare % %2) 0)]
     'match [regexp?* string? re-find]
     'pow   [number? number? #(Math/pow % %2)]
     'atan2 [number? number? #(Math/atan2 % %2)]
     'logn  [number? number? #(/ (Math/log %) (Math/log %2))]})

  (defmulti compile-expr
    (fn [expr]
      (cond
        (sequential? expr) (let [op (first expr)]
                             (cond
                               (vararg-ops op) ::varargs
                               (unary-ops op)  ::unary
                               (binary-ops op) ::binary
                               :else           op))
        (ff/qvar? expr)    ::qvar
        :else              ::const)))

  (defmethod compile-expr ::const
    [const] (fn [_] const))

  (defmethod compile-expr ::qvar
    [qvar] #(% qvar))

  (defmethod compile-expr ::varargs
    [[op & more]]
    (let [[check op] (vararg-ops op)
          args (mapv compile-expr more)]
      (if check
        (fn [res]
          (let [args' (sequence (comp (map #(% res)) (filter identity)) args)]
            (when (every? check args')
              (apply op args'))))
        (fn [res]
          (apply op (sequence (comp (map #(% res)) (filter identity)) args))))))

  (defmethod compile-expr ::unary
    [[op x]]
    (let [[check op] (unary-ops op)
          x (compile-expr x)]
      (if check
        (fn [res] (let [x' (x res)] (when (check x') (op x'))))
        (fn [res] (op (x res))))))

  (defmethod compile-expr ::binary
    [[op x y]]
    (let [[checkx checky op] (binary-ops op)
          x (compile-expr x)
          y (compile-expr y)]
      (cond
        (and checkx checky) (fn [res]
                              (let [x' (x res) y' (y res)]
                                (when (and (checkx x') (checky y')) (op x' y'))))
        checkx              (fn [res]
                              (let [x' (x res) y' (y res)]
                                (when (checkx x') (op x' y'))))
        checky              (fn [res]
                              (let [x' (x res) y' (y res)]
                                (when (checky y') (op x' y'))))
        :else               (fn [res] (op (x res) (y res))))))

  (defmethod compile-expr 'and
    [[_ & more]]
    (let [args (mapv compile-expr more)]
      (fn [res] (every? #(% res) args))))

  (defmethod compile-expr 'or
    [[_ & more]]
    (let [args (mapv compile-expr more)]
      (fn [res] (some #(% res) args))))

  (defmethod compile-expr 'match
    [[_ re x]]
    (let [x (compile-expr x)]
      (fn [res] (let [x' (x res)] (when (string? x') (re-find re x'))))))

  (defmethod compile-expr 'in-set?
    [[_ x & more]]
    (let [x       (compile-expr x)
          choices (mapv compile-expr more)]
      (fn [res] (let [x' (x res)] (some #(= (% res) x') choices)))))
#+END_SRC

*** Aggregation expressions

#+BEGIN_SRC clojure :noweb-ref expr
  (defn aggregation-with
    [op x]
    (let [x  (compile-expr x)
          tx (comp (map x) (filter identity))]
      (fn [results]
        (when (seq results)
          (transduce tx op results)))))

  (def min* (fn ([] nil) ([x] x) ([x y] (if x (min x y) y))))
  (def max* (fn ([] nil) ([x] x) ([x y] (if x (max x y) y))))

  (defmethod compile-expr 'agg-sum
    [[_ x]]
    (aggregation-with + x))

  (defmethod compile-expr 'agg-min
    [[_ x]]
    (aggregation-with min* x))

  (defmethod compile-expr 'agg-max
    [[_ x]]
    (aggregation-with max* x))

  (defmethod compile-expr 'agg-avg
    [[_ x]]
    (let [x  (compile-expr x)
          tx (comp (map x) (filter identity))]
      (fn [results]
        (let [res (sequence tx results)]
          (when (seq res)
            (double (/ (reduce + res) (count res))))))))

  (defmethod compile-expr 'agg-mean
    [[_ x]]
    (let [x  (compile-expr x)
          tx (comp (map x) (filter identity))]
      (fn [results]
        (let [res (sequence tx results)]
          (nth (sort res) (bit-shift-right (count res) 1) nil)))))

  (defmethod compile-expr 'agg-collect
    [[_ x]]
    (let [x  (compile-expr x)
          tx (comp (map x) (filter identity))]
      (fn [results] (into #{} tx results))))

  (defmethod compile-expr 'agg-count
    [_] (fn [results] (count results)))
#+END_SRC

*** Grouping expressions

#+BEGIN_SRC clojure :noweb-ref expr
  (defmethod compile-expr 'group-bins-of
    [[_ x n]]
    (let [x (compile-expr x)]
      (fn [res] (* (Math/floor (/ (x res) n)) n))))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn regexp?*
    [x] #?(:clj (= java.util.regex.Pattern (type x)) :cljs (regexp? x)))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/fabric/facts/dsl.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.fabric.facts.dsl
    #?@(:clj
        [(:require
          [thi.ng.fabric.core :as f]
          [thi.ng.fabric.facts.core :as ff]
          [clojure.set :as set]
          [clojure.core.async :as a :refer [go go-loop chan close! <! >! alts! timeout]]
          [taoensso.timbre :refer [debug info warn]])]
        :cljs
        [(:require-macros
          [cljs.core.async.macros :refer [go go-loop]]
          [cljs-log.core :refer [debug info warn]])
         (:require
          [thi.ng.fabric.core :as f]
          [thi.ng.fabric.facts.core :as ff]
          [clojure.set :as set]
          [cljs.core.async :refer [chan close! <! >! alts! timeout]])]))

  <<helpers>>

  <<expr>>

  <<dsl>>

  <<dsl-public>>
#+END_SRC
